{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1: Investigating the Range as a Function of the Angle of Projection 1. Theoretical Foundation Projectile motion is a type of two-dimensional motion where an object is launched into the air with an initial velocity \\(v_0\\) at an angle \\(\\theta\\) relative to the horizontal. The motion can be analyzed by breaking it into horizontal (x) and vertical (y) components. 1.1 Equations of Motion The horizontal and vertical components of the initial velocity are: \\(v_{0x} = v_0 \\cos(\\theta)\\) \\(v_{0y} = v_0 \\sin(\\theta)\\) Using the kinematic equations, the motion in each direction is governed by: - Horizontal motion (constant velocity, no acceleration in the ideal case): \\(x = v_{0x} t = v_0 \\cos(\\theta) t\\) - Vertical motion (accelerated due to gravity): \\(y = v_{0y} t - \\frac{1}{2} g t^2\\) where: \\(g\\) is the acceleration due to gravity \\((9.81 \\text{ m/s}^2)\\) \\(t\\) is the time of flight. 1.2 Time of Flight The time of flight is determined by solving for when the projectile returns to the ground \\((y = 0)\\) : \\(t = \\frac{2 v_0 \\sin(\\theta)}{g}\\) 1.3 Range Equation The range \\(R\\) is the horizontal distance traveled when the projectile lands: \\(R = v_{0x} \\cdot t = v_0 \\cos(\\theta) \\cdot \\frac{2 v_0 \\sin(\\theta)}{g}\\) Using the identity \\(2 \\sin(\\theta) \\cos(\\theta) = \\sin(2\\theta)\\) , we get: \\(R = \\frac{v_0^2 \\sin(2\\theta)}{g}\\) 2. Analysis of the Range The range is maximized when \\(\\sin(2\\theta) = 1\\) , which occurs at \\(2\\theta = 90^\\circ\\) , or \\(\\theta = 45^\\circ\\) . If the initial velocity \\(v_0\\) increases, the range increases quadratically. If gravity \\(g\\) increases (e.g., on another planet), the range decreases. 3. Practical Applications Sports: Understanding projectile motion is crucial in games like soccer, basketball, and golf. Engineering: Used in ballistics, rocketry, and artillery targeting systems. Real-World Effects: Air resistance, wind, and uneven terrain can significantly alter the theoretical range. 4. Implementation: Python Simulation The following Python script simulates projectile motion and plots the range as a function of the angle of projection. import numpy as np import matplotlib.pyplot as plt def projectile_range(v0_l\u0131st, g=9.81): angles = np.linspace(0, 90, 100) # Angle range from 0 to 90 degrees angles_rad = np.radians(angles) # Convert degrees to radians ranges = (v0**2 * np.sin(2 * angles_rad)) / g # Compute range plt.figure(figsize=(8, 5)) plt.plot(angles, ranges, label=f'v0 = {v0} m/s') plt.xlabel(\"Angle (degrees)\") plt.ylabel(\"Range (m)\") plt.title(\"Projectile Range vs. Launch Angle\") plt.legend() plt.grid() plt.show() projectile_range(v0=20) V0=20 V0=45(TOP ONE) Explanation of the Graph This graph illustrates how the horizontal range of a projectile depends on the launch angle for different initial velocities ( \\( v_0 \\) ). Each curve represents a different initial velocity. The maximum range occurs at 45\u00b0 . As the initial velocity increases, the range increases quadratically ( \\( v_0^2 \\) ) . Lower initial velocities result in shorter ranges, while higher velocities allow the projectile to travel further. This helps in understanding how objects like balls, bullets, or rockets behave when launched at different speeds and angles. import numpy as np import matplotlib.pyplot as plt def projectile_range_multi_v0(v0_list, g=9.81): angles = np.linspace(0, 90, 100) angles_rad = np.radians(angles) plt.figure(figsize=(8, 5)) for v0 in v0_list: ranges = (v0**2 * np.sin(2 * angles_rad)) / g plt.plot(angles, ranges, label=f'v0 = {v0} m/s') plt.xlabel(\"Angle (degrees)\") plt.ylabel(\"Range (m)\") plt.title(\"Projectile Range vs. Launch Angle for Different v0\") plt.legend() plt.grid() plt.show() projectile_range_multi_v0([10, 20, 30, 40]) Explanation of the Graph This graph shows how the horizontal range of a projectile changes with the launch angle for different gravitational accelerations ( \\(g\\) ). Each curve represents a different gravitational environment: Earth ( \\(g = 9.81 \\, \\text{m/s}^2\\) ), Moon ( \\(g = 1.62 \\, \\text{m/s}^2\\) ), and Jupiter ( \\(g = 24.79 \\, \\text{m/s}^2\\) ). As gravity decreases (like on the Moon), the range increases for the same initial velocity. On higher gravity bodies (like Jupiter), the range decreases. This graph helps understand how the same projectile behaves differently in various planetary environments. import numpy as np import matplotlib.pyplot as plt def projectile_range_multi_g(v0=20, g_values=[9.81, 1.62, 24.79]): angles = np.linspace(0, 90, 100) angles_rad = np.radians(angles) g_labels = [\"Earth (9.81 m/s\u00b2)\", \"Moon (1.62 m/s\u00b2)\", \"Jupiter (24.79 m/s\u00b2)\"] plt.figure(figsize=(8, 5)) for g, label in zip(g_values, g_labels): ranges = (v0**2 * np.sin(2 * angles_rad)) / g plt.plot(angles, ranges, label=label) plt.xlabel(\"Angle (degrees)\") plt.ylabel(\"Range (m)\") plt.title(\"Projectile Range vs. Launch Angle for Different Gravities\") plt.legend() plt.grid() plt.show() # Example usage projectile_range_multi_g() 5. Frequently Asked Questions (FAQ) 1. At what angle is the maximum range achieved in projectile motion? The maximum range is achieved at 45\u00b0 because, at this angle, the horizontal and vertical components of the velocity are balanced, maximizing distance. 2. How does the initial velocity affect the range? The range increases quadratically (v\u2080\u00b2) as the initial velocity increases, meaning a faster launch gives the projectile more distance to travel. 3. What happens if gravity changes? A higher gravitational acceleration reduces the range because the projectile falls back to the ground more quickly, while a lower gravity increases the range by allowing the projectile to stay in the air longer. 4. Does mass affect the projectile's range? No, in ideal conditions without air resistance, mass does not affect the range because both heavy and light projectiles fall at the same rate under the same conditions. 5. How does air resistance impact projectile motion? Air resistance reduces the range by slowing down the projectile and changing its trajectory, making the optimal launch angle lower than 45\u00b0.","title":"Problem 1: Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1-investigating-the-range-as-a-function-of-the-angle-of-projection","text":"","title":"Problem 1: Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-theoretical-foundation","text":"Projectile motion is a type of two-dimensional motion where an object is launched into the air with an initial velocity \\(v_0\\) at an angle \\(\\theta\\) relative to the horizontal. The motion can be analyzed by breaking it into horizontal (x) and vertical (y) components.","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#11-equations-of-motion","text":"The horizontal and vertical components of the initial velocity are: \\(v_{0x} = v_0 \\cos(\\theta)\\) \\(v_{0y} = v_0 \\sin(\\theta)\\) Using the kinematic equations, the motion in each direction is governed by: - Horizontal motion (constant velocity, no acceleration in the ideal case): \\(x = v_{0x} t = v_0 \\cos(\\theta) t\\) - Vertical motion (accelerated due to gravity): \\(y = v_{0y} t - \\frac{1}{2} g t^2\\) where: \\(g\\) is the acceleration due to gravity \\((9.81 \\text{ m/s}^2)\\) \\(t\\) is the time of flight.","title":"1.1 Equations of Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#12-time-of-flight","text":"The time of flight is determined by solving for when the projectile returns to the ground \\((y = 0)\\) : \\(t = \\frac{2 v_0 \\sin(\\theta)}{g}\\)","title":"1.2 Time of Flight"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#13-range-equation","text":"The range \\(R\\) is the horizontal distance traveled when the projectile lands: \\(R = v_{0x} \\cdot t = v_0 \\cos(\\theta) \\cdot \\frac{2 v_0 \\sin(\\theta)}{g}\\) Using the identity \\(2 \\sin(\\theta) \\cos(\\theta) = \\sin(2\\theta)\\) , we get: \\(R = \\frac{v_0^2 \\sin(2\\theta)}{g}\\)","title":"1.3 Range Equation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-analysis-of-the-range","text":"The range is maximized when \\(\\sin(2\\theta) = 1\\) , which occurs at \\(2\\theta = 90^\\circ\\) , or \\(\\theta = 45^\\circ\\) . If the initial velocity \\(v_0\\) increases, the range increases quadratically. If gravity \\(g\\) increases (e.g., on another planet), the range decreases.","title":"2. Analysis of the Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-practical-applications","text":"Sports: Understanding projectile motion is crucial in games like soccer, basketball, and golf. Engineering: Used in ballistics, rocketry, and artillery targeting systems. Real-World Effects: Air resistance, wind, and uneven terrain can significantly alter the theoretical range.","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-implementation-python-simulation","text":"The following Python script simulates projectile motion and plots the range as a function of the angle of projection. import numpy as np import matplotlib.pyplot as plt def projectile_range(v0_l\u0131st, g=9.81): angles = np.linspace(0, 90, 100) # Angle range from 0 to 90 degrees angles_rad = np.radians(angles) # Convert degrees to radians ranges = (v0**2 * np.sin(2 * angles_rad)) / g # Compute range plt.figure(figsize=(8, 5)) plt.plot(angles, ranges, label=f'v0 = {v0} m/s') plt.xlabel(\"Angle (degrees)\") plt.ylabel(\"Range (m)\") plt.title(\"Projectile Range vs. Launch Angle\") plt.legend() plt.grid() plt.show() projectile_range(v0=20)","title":"4. Implementation: Python Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#v020","text":"","title":"V0=20"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#v045top-one","text":"","title":"V0=45(TOP ONE)"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#explanation-of-the-graph","text":"This graph illustrates how the horizontal range of a projectile depends on the launch angle for different initial velocities ( \\( v_0 \\) ). Each curve represents a different initial velocity. The maximum range occurs at 45\u00b0 . As the initial velocity increases, the range increases quadratically ( \\( v_0^2 \\) ) . Lower initial velocities result in shorter ranges, while higher velocities allow the projectile to travel further. This helps in understanding how objects like balls, bullets, or rockets behave when launched at different speeds and angles. import numpy as np import matplotlib.pyplot as plt def projectile_range_multi_v0(v0_list, g=9.81): angles = np.linspace(0, 90, 100) angles_rad = np.radians(angles) plt.figure(figsize=(8, 5)) for v0 in v0_list: ranges = (v0**2 * np.sin(2 * angles_rad)) / g plt.plot(angles, ranges, label=f'v0 = {v0} m/s') plt.xlabel(\"Angle (degrees)\") plt.ylabel(\"Range (m)\") plt.title(\"Projectile Range vs. Launch Angle for Different v0\") plt.legend() plt.grid() plt.show() projectile_range_multi_v0([10, 20, 30, 40])","title":"Explanation of the Graph"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#explanation-of-the-graph_1","text":"This graph shows how the horizontal range of a projectile changes with the launch angle for different gravitational accelerations ( \\(g\\) ). Each curve represents a different gravitational environment: Earth ( \\(g = 9.81 \\, \\text{m/s}^2\\) ), Moon ( \\(g = 1.62 \\, \\text{m/s}^2\\) ), and Jupiter ( \\(g = 24.79 \\, \\text{m/s}^2\\) ). As gravity decreases (like on the Moon), the range increases for the same initial velocity. On higher gravity bodies (like Jupiter), the range decreases. This graph helps understand how the same projectile behaves differently in various planetary environments. import numpy as np import matplotlib.pyplot as plt def projectile_range_multi_g(v0=20, g_values=[9.81, 1.62, 24.79]): angles = np.linspace(0, 90, 100) angles_rad = np.radians(angles) g_labels = [\"Earth (9.81 m/s\u00b2)\", \"Moon (1.62 m/s\u00b2)\", \"Jupiter (24.79 m/s\u00b2)\"] plt.figure(figsize=(8, 5)) for g, label in zip(g_values, g_labels): ranges = (v0**2 * np.sin(2 * angles_rad)) / g plt.plot(angles, ranges, label=label) plt.xlabel(\"Angle (degrees)\") plt.ylabel(\"Range (m)\") plt.title(\"Projectile Range vs. Launch Angle for Different Gravities\") plt.legend() plt.grid() plt.show() # Example usage projectile_range_multi_g()","title":"Explanation of the Graph"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#5-frequently-asked-questions-faq","text":"","title":"5. Frequently Asked Questions (FAQ)"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-at-what-angle-is-the-maximum-range-achieved-in-projectile-motion","text":"The maximum range is achieved at 45\u00b0 because, at this angle, the horizontal and vertical components of the velocity are balanced, maximizing distance.","title":"1. At what angle is the maximum range achieved in projectile motion?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-how-does-the-initial-velocity-affect-the-range","text":"The range increases quadratically (v\u2080\u00b2) as the initial velocity increases, meaning a faster launch gives the projectile more distance to travel.","title":"2. How does the initial velocity affect the range?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-what-happens-if-gravity-changes","text":"A higher gravitational acceleration reduces the range because the projectile falls back to the ground more quickly, while a lower gravity increases the range by allowing the projectile to stay in the air longer.","title":"3. What happens if gravity changes?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-does-mass-affect-the-projectiles-range","text":"No, in ideal conditions without air resistance, mass does not affect the range because both heavy and light projectiles fall at the same rate under the same conditions.","title":"4. Does mass affect the projectile's range?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#5-how-does-air-resistance-impact-projectile-motion","text":"Air resistance reduces the range by slowing down the projectile and changing its trajectory, making the optimal launch angle lower than 45\u00b0.","title":"5. How does air resistance impact projectile motion?"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Investigating the Dynamics of a Forced Damped Pendulum Motivation The forced damped pendulum is a classic example of nonlinear dynamics. Unlike simple harmonic oscillators, this system responds to periodic external forces and damping, producing rich behavior that includes resonance, synchronization, and even chaos. This kind of system is fundamental in physics and engineering because it mirrors the behavior of real-world systems like suspension bridges, circuits, and mechanical vibration absorbers. 1. Theoretical Foundation The general nonlinear equation for the forced damped pendulum is: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\sin\\theta = A \\cos(\\omega t) \\] Where: - \\(\\theta\\) : angular displacement (radians) - \\(\\gamma\\) : damping coefficient (how quickly oscillations die out) - \\(\\omega_0\\) : natural angular frequency ( \\(\\omega_0 = \\sqrt{g / L}\\) for a pendulum of length \\(L\\) ) - \\(A\\) : amplitude of external force - \\(\\omega\\) : driving frequency Small-Angle Approximation When \\(\\theta\\) is small (typically less than 10\u00b0), we can use the approximation: \\[ \\sin\\theta \\approx \\theta \\] This simplifies the equation to: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = A \\cos(\\omega t) \\] This form is a linear second-order ODE, easier to solve and useful for studying resonance behavior. 2. Python Simulation Let's simulate the pendulum using numerical methods. We'll use the Runge-Kutta method via scipy.integrate.solve_ivp . import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Differential equation def pendulum(t, y, gamma, omega0, A, omega): theta, omega_theta = y dydt = [omega_theta, -gamma * omega_theta - omega0**2 * np.sin(theta) + A * np.cos(omega * t)] return dydt # Parameters gamma = 0.2 omega0 = 1.5 A = 1.2 omega_drive = 2.0 y0 = [0.1, 0.0] t_span = (0, 50) t_eval = np.linspace(*t_span, 5000) # Solve the system sol = solve_ivp(pendulum, t_span, y0, t_eval=t_eval, args=(gamma, omega0, A, omega_drive)) # Plot angle over time plt.figure(figsize=(10, 4)) plt.plot(sol.t, sol.y[0], label='\u03b8(t)') plt.title('Angle vs Time') plt.xlabel('Time (s)') plt.ylabel('Angle (rad)') plt.grid(True) plt.legend() plt.show() 3. Phase Space (\u03b8 vs \u03c9) This plot helps visualize how the system evolves in state space. plt.figure(figsize=(6, 6)) plt.plot(sol.y[0], sol.y[1]) plt.title('Phase Space') plt.xlabel('Angle \u03b8 (rad)') plt.ylabel('Angular Velocity \u03c9 (rad/s)') plt.grid(True) plt.show() 4. Poincar\u00e9 Section The Poincar\u00e9 section samples the system once per driving cycle, helping identify periodicity and chaos. T = 2 * np.pi / omega_drive poincare_times = np.arange(0, t_span[1], T) poincare_points = [] for t_p in poincare_times: idx = np.argmin(np.abs(sol.t - t_p)) poincare_points.append([sol.y[0][idx] % (2*np.pi), sol.y[1][idx]]) poincare_points = np.array(poincare_points) plt.figure(figsize=(6, 6)) plt.scatter(poincare_points[:, 0], poincare_points[:, 1], s=10, color='crimson') plt.title('Poincar\u00e9 Section') plt.xlabel('\u03b8 mod $2\\pi$ (rad)') plt.ylabel('Angular Velocity (rad/s)') plt.grid(True) plt.show() 5. Additional Visualization: Energy Over Time Visualizing total mechanical energy shows how damping and driving force interact. mass = 1.0 length = 1.0 g = 9.81 theta = sol.y[0] omega = sol.y[1] potential_energy = mass * g * length * (1 - np.cos(theta)) kinetic_energy = 0.5 * mass * (length**2) * omega**2 total_energy = potential_energy + kinetic_energy plt.figure(figsize=(10, 4)) plt.plot(sol.t, total_energy) plt.title('Total Mechanical Energy vs Time') plt.xlabel('Time (s)') plt.ylabel('Energy (J)') plt.grid(True) plt.show() 6. Bifurcation Diagram Explore how the long-term behavior changes with the driving amplitude A. bifurcation_A = np.linspace(1.0, 1.5, 300) steady_states = [] for A_val in bifurcation_A: sol = solve_ivp(pendulum, [0, 200], [0.1, 0.0], t_eval=np.linspace(150, 200, 500), args=(gamma, omega0, A_val, omega_drive)) theta_vals = sol.y[0] % (2 * np.pi) steady_states.append((np.full_like(theta_vals, A_val), theta_vals)) plt.figure(figsize=(10, 6)) for A_vals, thetas in steady_states: plt.plot(A_vals, thetas, ',k', alpha=0.5) plt.title(\"Bifurcation Diagram (A vs \u03b8)\") plt.xlabel(\"Driving Amplitude A\") plt.ylabel(\"\u03b8 mod 2\u03c0\") plt.grid(True) plt.show() 7. Lyapunov Exponent Estimation Estimate the largest Lyapunov exponent to determine chaos. def estimate_lyapunov(delta0=1e-8, T_max=100): y1 = np.array([0.1, 0.0]) y2 = y1 + np.array([delta0, 0]) times = np.linspace(0, T_max, 10000) d_list = [] for t in range(len(times) - 1): sol1 = solve_ivp(pendulum, [times[t], times[t+1]], y1, t_eval=[times[t+1]], args=(gamma, omega0, A, omega_drive)) sol2 = solve_ivp(pendulum, [times[t], times[t+1]], y2, t_eval=[times[t+1]], args=(gamma, omega0, A, omega_drive)) y1 = sol1.y[:, -1] y2 = sol2.y[:, -1] delta = np.linalg.norm(y2 - y1) d_list.append(np.log(delta / delta0)) y2 = y1 + delta0 * (y2 - y1) / delta # Renormalize return times[1:], np.cumsum(d_list) / np.arange(1, len(d_list)+1) ltimes, lyap = estimate_lyapunov() plt.figure(figsize=(8, 4)) plt.plot(ltimes, lyap) plt.title(\"Estimated Largest Lyapunov Exponent\") plt.xlabel(\"Time\") plt.ylabel(\"Lyapunov Exponent\") plt.grid(True) plt.show() 8. Exploring Parameters Experimenting with parameters leads to different behaviors: - Increasing A may cause chaotic motion. - Lowering \u03b3 shows less damping, leading to longer sustained oscillations. - Matching \u03c9 with \u03c9\u2080 creates resonance, producing large amplitudes. \ud83d\udd04 Extended Visualization: Adding Forced but Undamped Pendulum This scenario demonstrates periodic motion with sustained energy input and no damping, resulting in regular oscillations without energy loss \u2014 a resonance-friendly setup. We now add the fourth scenario that was previously missing: Case Damping ( \\(b\\) ) Forcing ( \\(A\\) ) Simple Pendulum 0 0 Damped Pendulum 0.5 0 Forced Damped Pendulum 0.5 1.2 Forced (Undamped) Pendulum 0 1.2 \u2705 NEW This configuration shows how the system behaves when it's driven but has no energy loss \u2013 a potentially resonant and unstable regime. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp g = 9.81 L = 1.0 omega0 = np.sqrt(g / L) theta0 = 0.2 omega_init = 0.0 t_span = (0, 30) t_eval = np.linspace(*t_span, 5000) def pendulum_system(t, y, gamma, A, omega_drive): theta, omega = y dtheta_dt = omega domega_dt = -gamma * omega - omega0**2 * np.sin(theta) + A * np.cos(omega_drive * t) return [dtheta_dt, domega_dt] gamma_forced_undamped = 0.0 A_forced = 1.2 omega_drive = 2.0 sol_forced_undamped = solve_ivp(pendulum_system, t_span, [theta0, omega_init], t_eval=t_eval, args=(gamma_forced_undamped, A_forced, omega_drive)) plt.figure(figsize=(12, 5)) plt.subplot(1, 2, 1) plt.plot(sol_forced_undamped.t, sol_forced_undamped.y[0]) plt.title(\"Forced (Undamped) Pendulum: Angle vs Time\") plt.xlabel(\"Time (s)\") plt.ylabel(\"Angle $\\\\theta$ (rad)\") plt.grid(True) plt.subplot(1, 2, 2) plt.plot(sol_forced_undamped.y[0], sol_forced_undamped.y[1]) plt.title(\"Forced (Undamped) Pendulum: Phase Space\") plt.xlabel(\"Angle $\\\\theta$ (rad)\") plt.ylabel(\"Angular Velocity $\\\\omega$ (rad/s)\") plt.grid(True) plt.tight_layout() plt.show() 9. Real-World Applications Energy Harvesters : Pendulums can convert motion into usable energy. Bridge Engineering : Avoiding resonance in suspension bridges is crucial. Washing Machines : Proper damping reduces imbalance. Electronics : RLC circuits have similar equations. Clocks : Pendulum clocks are based on resonance principles. 10. Model Limitations and Extensions The model assumes ideal sine driving forces. Real-world damping is often nonlinear. It doesn't account for multi-dimensional motion. Possible Extensions Add random or non-periodic forcing. Add nonlinear damping (quadratic drag). Study bifurcation diagrams over varying A or \u03c9. Simulate coupled or double pendulums. To fully illustrate the transition from simple to complex dynamics, we add simulations for: Simple Pendulum (no damping, no forcing) Damped Pendulum (with damping, no forcing) Forced Damped Pendulum (already shown above) We simulate and visualize angle-time plots and phase diagrams for the first two to complete the progression. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp g = 9.81 L = 1.0 omega0 = np.sqrt(g / L) theta0 = 0.2 omega_init = 0.0 t_span = (0, 30) t_eval = np.linspace(*t_span, 5000) def pendulum_system(t, y, gamma, A, omega_drive): theta, omega = y dtheta_dt = omega domega_dt = -gamma * omega - omega0**2 * np.sin(theta) + A * np.cos(omega_drive * t) return [dtheta_dt, domega_dt] sol_simple = solve_ivp(pendulum_system, t_span, [theta0, omega_init], t_eval=t_eval, args=(0.0, 0.0, 0.0)) sol_damped = solve_ivp(pendulum_system, t_span, [theta0, omega_init], t_eval=t_eval, args=(0.5, 0.0, 0.0)) plt.figure(figsize=(14, 10)) plt.subplot(2, 2, 1) plt.plot(sol_simple.t, sol_simple.y[0]) plt.title(\"Simple Pendulum: Angle vs Time\") plt.xlabel(\"Time (s)\") plt.ylabel(\"Angle $\\\\theta$ (rad)\") plt.grid(True) plt.subplot(2, 2, 2) plt.plot(sol_simple.y[0], sol_simple.y[1]) plt.title(\"Simple Pendulum: Phase Space\") plt.xlabel(\"Angle $\\\\theta$ (rad)\") plt.ylabel(\"Angular Velocity $\\\\omega$ (rad/s)\") plt.grid(True) plt.subplot(2, 2, 3) plt.plot(sol_damped.t, sol_damped.y[0]) plt.title(\"Damped Pendulum: Angle vs Time\") plt.xlabel(\"Time (s)\") plt.ylabel(\"Angle $\\\\theta$ (rad)\") plt.grid(True) plt.subplot(2, 2, 4) plt.plot(sol_damped.y[0], sol_damped.y[1]) plt.title(\"Damped Pendulum: Phase Space\") plt.xlabel(\"Angle $\\\\theta$ (rad)\") plt.ylabel(\"Angular Velocity $\\\\omega$ (rad/s)\") plt.grid(True) plt.tight_layout() plt.show()","title":"Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#investigating-the-dynamics-of-a-forced-damped-pendulum","text":"","title":"Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#motivation","text":"The forced damped pendulum is a classic example of nonlinear dynamics. Unlike simple harmonic oscillators, this system responds to periodic external forces and damping, producing rich behavior that includes resonance, synchronization, and even chaos. This kind of system is fundamental in physics and engineering because it mirrors the behavior of real-world systems like suspension bridges, circuits, and mechanical vibration absorbers.","title":"Motivation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-theoretical-foundation","text":"The general nonlinear equation for the forced damped pendulum is: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\sin\\theta = A \\cos(\\omega t) \\] Where: - \\(\\theta\\) : angular displacement (radians) - \\(\\gamma\\) : damping coefficient (how quickly oscillations die out) - \\(\\omega_0\\) : natural angular frequency ( \\(\\omega_0 = \\sqrt{g / L}\\) for a pendulum of length \\(L\\) ) - \\(A\\) : amplitude of external force - \\(\\omega\\) : driving frequency","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#small-angle-approximation","text":"When \\(\\theta\\) is small (typically less than 10\u00b0), we can use the approximation: \\[ \\sin\\theta \\approx \\theta \\] This simplifies the equation to: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = A \\cos(\\omega t) \\] This form is a linear second-order ODE, easier to solve and useful for studying resonance behavior.","title":"Small-Angle Approximation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-python-simulation","text":"Let's simulate the pendulum using numerical methods. We'll use the Runge-Kutta method via scipy.integrate.solve_ivp . import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Differential equation def pendulum(t, y, gamma, omega0, A, omega): theta, omega_theta = y dydt = [omega_theta, -gamma * omega_theta - omega0**2 * np.sin(theta) + A * np.cos(omega * t)] return dydt # Parameters gamma = 0.2 omega0 = 1.5 A = 1.2 omega_drive = 2.0 y0 = [0.1, 0.0] t_span = (0, 50) t_eval = np.linspace(*t_span, 5000) # Solve the system sol = solve_ivp(pendulum, t_span, y0, t_eval=t_eval, args=(gamma, omega0, A, omega_drive)) # Plot angle over time plt.figure(figsize=(10, 4)) plt.plot(sol.t, sol.y[0], label='\u03b8(t)') plt.title('Angle vs Time') plt.xlabel('Time (s)') plt.ylabel('Angle (rad)') plt.grid(True) plt.legend() plt.show()","title":"2. Python Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-phase-space-vs","text":"This plot helps visualize how the system evolves in state space. plt.figure(figsize=(6, 6)) plt.plot(sol.y[0], sol.y[1]) plt.title('Phase Space') plt.xlabel('Angle \u03b8 (rad)') plt.ylabel('Angular Velocity \u03c9 (rad/s)') plt.grid(True) plt.show()","title":"3. Phase Space (\u03b8 vs \u03c9)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#_1","text":"","title":""},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-poincare-section","text":"The Poincar\u00e9 section samples the system once per driving cycle, helping identify periodicity and chaos. T = 2 * np.pi / omega_drive poincare_times = np.arange(0, t_span[1], T) poincare_points = [] for t_p in poincare_times: idx = np.argmin(np.abs(sol.t - t_p)) poincare_points.append([sol.y[0][idx] % (2*np.pi), sol.y[1][idx]]) poincare_points = np.array(poincare_points) plt.figure(figsize=(6, 6)) plt.scatter(poincare_points[:, 0], poincare_points[:, 1], s=10, color='crimson') plt.title('Poincar\u00e9 Section') plt.xlabel('\u03b8 mod $2\\pi$ (rad)') plt.ylabel('Angular Velocity (rad/s)') plt.grid(True) plt.show()","title":"4. Poincar\u00e9 Section"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#5-additional-visualization-energy-over-time","text":"Visualizing total mechanical energy shows how damping and driving force interact. mass = 1.0 length = 1.0 g = 9.81 theta = sol.y[0] omega = sol.y[1] potential_energy = mass * g * length * (1 - np.cos(theta)) kinetic_energy = 0.5 * mass * (length**2) * omega**2 total_energy = potential_energy + kinetic_energy plt.figure(figsize=(10, 4)) plt.plot(sol.t, total_energy) plt.title('Total Mechanical Energy vs Time') plt.xlabel('Time (s)') plt.ylabel('Energy (J)') plt.grid(True) plt.show()","title":"5. Additional Visualization: Energy Over Time"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#6-bifurcation-diagram","text":"Explore how the long-term behavior changes with the driving amplitude A. bifurcation_A = np.linspace(1.0, 1.5, 300) steady_states = [] for A_val in bifurcation_A: sol = solve_ivp(pendulum, [0, 200], [0.1, 0.0], t_eval=np.linspace(150, 200, 500), args=(gamma, omega0, A_val, omega_drive)) theta_vals = sol.y[0] % (2 * np.pi) steady_states.append((np.full_like(theta_vals, A_val), theta_vals)) plt.figure(figsize=(10, 6)) for A_vals, thetas in steady_states: plt.plot(A_vals, thetas, ',k', alpha=0.5) plt.title(\"Bifurcation Diagram (A vs \u03b8)\") plt.xlabel(\"Driving Amplitude A\") plt.ylabel(\"\u03b8 mod 2\u03c0\") plt.grid(True) plt.show()","title":"6. Bifurcation Diagram"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#7-lyapunov-exponent-estimation","text":"Estimate the largest Lyapunov exponent to determine chaos. def estimate_lyapunov(delta0=1e-8, T_max=100): y1 = np.array([0.1, 0.0]) y2 = y1 + np.array([delta0, 0]) times = np.linspace(0, T_max, 10000) d_list = [] for t in range(len(times) - 1): sol1 = solve_ivp(pendulum, [times[t], times[t+1]], y1, t_eval=[times[t+1]], args=(gamma, omega0, A, omega_drive)) sol2 = solve_ivp(pendulum, [times[t], times[t+1]], y2, t_eval=[times[t+1]], args=(gamma, omega0, A, omega_drive)) y1 = sol1.y[:, -1] y2 = sol2.y[:, -1] delta = np.linalg.norm(y2 - y1) d_list.append(np.log(delta / delta0)) y2 = y1 + delta0 * (y2 - y1) / delta # Renormalize return times[1:], np.cumsum(d_list) / np.arange(1, len(d_list)+1) ltimes, lyap = estimate_lyapunov() plt.figure(figsize=(8, 4)) plt.plot(ltimes, lyap) plt.title(\"Estimated Largest Lyapunov Exponent\") plt.xlabel(\"Time\") plt.ylabel(\"Lyapunov Exponent\") plt.grid(True) plt.show()","title":"7. Lyapunov Exponent Estimation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#8-exploring-parameters","text":"Experimenting with parameters leads to different behaviors: - Increasing A may cause chaotic motion. - Lowering \u03b3 shows less damping, leading to longer sustained oscillations. - Matching \u03c9 with \u03c9\u2080 creates resonance, producing large amplitudes.","title":"8. Exploring Parameters"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#extended-visualization-adding-forced-but-undamped-pendulum","text":"This scenario demonstrates periodic motion with sustained energy input and no damping, resulting in regular oscillations without energy loss \u2014 a resonance-friendly setup. We now add the fourth scenario that was previously missing: Case Damping ( \\(b\\) ) Forcing ( \\(A\\) ) Simple Pendulum 0 0 Damped Pendulum 0.5 0 Forced Damped Pendulum 0.5 1.2 Forced (Undamped) Pendulum 0 1.2 \u2705 NEW This configuration shows how the system behaves when it's driven but has no energy loss \u2013 a potentially resonant and unstable regime. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp g = 9.81 L = 1.0 omega0 = np.sqrt(g / L) theta0 = 0.2 omega_init = 0.0 t_span = (0, 30) t_eval = np.linspace(*t_span, 5000) def pendulum_system(t, y, gamma, A, omega_drive): theta, omega = y dtheta_dt = omega domega_dt = -gamma * omega - omega0**2 * np.sin(theta) + A * np.cos(omega_drive * t) return [dtheta_dt, domega_dt] gamma_forced_undamped = 0.0 A_forced = 1.2 omega_drive = 2.0 sol_forced_undamped = solve_ivp(pendulum_system, t_span, [theta0, omega_init], t_eval=t_eval, args=(gamma_forced_undamped, A_forced, omega_drive)) plt.figure(figsize=(12, 5)) plt.subplot(1, 2, 1) plt.plot(sol_forced_undamped.t, sol_forced_undamped.y[0]) plt.title(\"Forced (Undamped) Pendulum: Angle vs Time\") plt.xlabel(\"Time (s)\") plt.ylabel(\"Angle $\\\\theta$ (rad)\") plt.grid(True) plt.subplot(1, 2, 2) plt.plot(sol_forced_undamped.y[0], sol_forced_undamped.y[1]) plt.title(\"Forced (Undamped) Pendulum: Phase Space\") plt.xlabel(\"Angle $\\\\theta$ (rad)\") plt.ylabel(\"Angular Velocity $\\\\omega$ (rad/s)\") plt.grid(True) plt.tight_layout() plt.show()","title":"\ud83d\udd04 Extended Visualization: Adding Forced but Undamped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#9-real-world-applications","text":"Energy Harvesters : Pendulums can convert motion into usable energy. Bridge Engineering : Avoiding resonance in suspension bridges is crucial. Washing Machines : Proper damping reduces imbalance. Electronics : RLC circuits have similar equations. Clocks : Pendulum clocks are based on resonance principles.","title":"9. Real-World Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#10-model-limitations-and-extensions","text":"The model assumes ideal sine driving forces. Real-world damping is often nonlinear. It doesn't account for multi-dimensional motion.","title":"10. Model Limitations and Extensions"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#possible-extensions","text":"Add random or non-periodic forcing. Add nonlinear damping (quadratic drag). Study bifurcation diagrams over varying A or \u03c9. Simulate coupled or double pendulums. To fully illustrate the transition from simple to complex dynamics, we add simulations for: Simple Pendulum (no damping, no forcing) Damped Pendulum (with damping, no forcing) Forced Damped Pendulum (already shown above) We simulate and visualize angle-time plots and phase diagrams for the first two to complete the progression. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp g = 9.81 L = 1.0 omega0 = np.sqrt(g / L) theta0 = 0.2 omega_init = 0.0 t_span = (0, 30) t_eval = np.linspace(*t_span, 5000) def pendulum_system(t, y, gamma, A, omega_drive): theta, omega = y dtheta_dt = omega domega_dt = -gamma * omega - omega0**2 * np.sin(theta) + A * np.cos(omega_drive * t) return [dtheta_dt, domega_dt] sol_simple = solve_ivp(pendulum_system, t_span, [theta0, omega_init], t_eval=t_eval, args=(0.0, 0.0, 0.0)) sol_damped = solve_ivp(pendulum_system, t_span, [theta0, omega_init], t_eval=t_eval, args=(0.5, 0.0, 0.0)) plt.figure(figsize=(14, 10)) plt.subplot(2, 2, 1) plt.plot(sol_simple.t, sol_simple.y[0]) plt.title(\"Simple Pendulum: Angle vs Time\") plt.xlabel(\"Time (s)\") plt.ylabel(\"Angle $\\\\theta$ (rad)\") plt.grid(True) plt.subplot(2, 2, 2) plt.plot(sol_simple.y[0], sol_simple.y[1]) plt.title(\"Simple Pendulum: Phase Space\") plt.xlabel(\"Angle $\\\\theta$ (rad)\") plt.ylabel(\"Angular Velocity $\\\\omega$ (rad/s)\") plt.grid(True) plt.subplot(2, 2, 3) plt.plot(sol_damped.t, sol_damped.y[0]) plt.title(\"Damped Pendulum: Angle vs Time\") plt.xlabel(\"Time (s)\") plt.ylabel(\"Angle $\\\\theta$ (rad)\") plt.grid(True) plt.subplot(2, 2, 4) plt.plot(sol_damped.y[0], sol_damped.y[1]) plt.title(\"Damped Pendulum: Phase Space\") plt.xlabel(\"Angle $\\\\theta$ (rad)\") plt.ylabel(\"Angular Velocity $\\\\omega$ (rad/s)\") plt.grid(True) plt.tight_layout() plt.show()","title":"Possible Extensions"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1: Investigating the Relationship Between Orbital Period and Orbital Radius 1. Theoretical Foundation Orbital mechanics describes how celestial bodies move under the influence of gravitational forces. A key concept is Kepler's Third Law , which states that the square of the orbital period ( \\(T^2\\) ) is proportional to the cube of the orbital radius ( \\(r^3\\) ). 1.1 Equations of Motion In circular orbits, the gravitational force provides the necessary centripetal force: Gravitational Force: $$ F_{\\text{gravity}} = \\frac{G M m}{r^2} $$ Centripetal Force: $$ F_{\\text{centripetal}} = \\frac{m v^2}{r} $$ Setting them equal: $$ \\frac{G M m}{r^2} = \\frac{m v^2}{r} $$ Simplifying: $$ v^2 = \\frac{G M}{r} $$ The orbital period \\(T\\) is the time taken to complete one orbit: \\[ T = \\frac{2\\pi r}{v} \\] Substituting \\(v\\) : $$ T = 2\\pi r \\sqrt{\\frac{r}{G M}} $$ Squaring both sides: $$ T^2 = \\frac{4\\pi^2 r^3}{G M} $$ Thus, the square of the orbital period is proportional to the cube of the orbital radius: \\[ T^2 \\propto r^3 \\] 2. Analysis of the Relationship The larger the orbital radius, the longer the period of revolution. A more massive central body (larger \\(M\\) ) results in shorter orbital periods for a given radius. This relationship is foundational for determining distances and masses in astronomy. 3. Practical Applications Satellite Deployment: Designing satellite orbits around Earth or other planets. Planetary Mass Calculation: Determining the mass of celestial bodies by observing their moons. Exoplanet Studies: Finding exoplanets and their orbital characteristics around distant stars. 4. Implementation: Python Simulation The following Python script simulates circular orbits and verifies the relationship between \\(T^2\\) and \\(r^3\\) . import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # gravitational constant (m^3 kg^-1 s^-2) M = 5.972e24 # mass of Earth (kg) # Function to compute orbital period def orbital_period(r): return 2 * np.pi * np.sqrt(r**3 / (G * M)) # Range of orbital radii radii = np.linspace(7e6, 5e7, 100) # from 7000 km to 50000 km (converted to meters) periods = orbital_period(radii) # Plotting T^2 vs r^3 plt.figure(figsize=(8, 5)) plt.plot(radii**3, periods**2, label='T\u00b2 vs r\u00b3') plt.xlabel(\"Orbital Radius Cubed ($r^3$) [m\u00b3]\") plt.ylabel(\"Orbital Period Squared ($T^2$) [s\u00b2]\") plt.title(\"Verification of Kepler's Third Law\") plt.legend() plt.grid() plt.show() # Plotting Orbits theta = np.linspace(0, 2*np.pi, 100) plt.figure(figsize=(8,8)) for r in np.linspace(7e6, 4e7, 5): x = r * np.cos(theta) y = r * np.sin(theta) plt.plot(x, y, label=f'Radius = {r/1000:.0f} km') plt.scatter(0, 0, color='yellow', label='Earth') # Earth at center plt.xlabel(\"x position (m)\") plt.ylabel(\"y position (m)\") plt.title(\"Circular Orbits around Earth\") plt.legend() plt.grid() plt.axis('equal') plt.show() 5. Explanation of the Graphs Graph 1: T\u00b2 vs r\u00b3 This graph demonstrates the linear relationship between the square of the orbital period ( \\(T^2\\) ) and the cube of the orbital radius ( \\(r^3\\) ). As \\(r^3\\) increases, \\(T^2\\) also increases linearly. This verifies Kepler's Third Law for circular orbits. Graph 2: Visualization of Orbits Shows circular orbits for satellites at different radii. Earth is placed at the center. Larger orbital radius corresponds to a larger orbit and a longer period. These visualizations help understand how satellites and moons move around their parent bodies. 6. Frequently Asked Questions (FAQ) 1. What does Kepler's Third Law state for circular orbits? It states that the square of the orbital period ( \\(T^2\\) ) is directly proportional to the cube of the orbital radius ( \\(r^3\\) ). 2. Does the mass of the satellite affect the orbital period? No, the satellite's mass cancels out in the equations; only the central mass ( \\(M\\) ) and the orbital radius ( \\(r\\) ) matter. 3. How is this law useful in real-world applications? It is used in calculating satellite orbits, determining planetary masses, and studying exoplanets. 4. What happens if the central body's mass increases? If \\(M\\) increases, the orbital period for a given radius decreases (i.e., objects orbit faster). 5. Does this relationship apply to elliptical orbits? Yes, but \\(r\\) is replaced with the semi-major axis ( \\(a\\) ) of the ellipse in the general form of Kepler's Third Law.","title":"Problem 1: Investigating the Relationship Between Orbital Period and Orbital Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1-investigating-the-relationship-between-orbital-period-and-orbital-radius","text":"","title":"Problem 1: Investigating the Relationship Between Orbital Period and Orbital Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-theoretical-foundation","text":"Orbital mechanics describes how celestial bodies move under the influence of gravitational forces. A key concept is Kepler's Third Law , which states that the square of the orbital period ( \\(T^2\\) ) is proportional to the cube of the orbital radius ( \\(r^3\\) ).","title":"1. Theoretical Foundation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#11-equations-of-motion","text":"In circular orbits, the gravitational force provides the necessary centripetal force: Gravitational Force: $$ F_{\\text{gravity}} = \\frac{G M m}{r^2} $$ Centripetal Force: $$ F_{\\text{centripetal}} = \\frac{m v^2}{r} $$ Setting them equal: $$ \\frac{G M m}{r^2} = \\frac{m v^2}{r} $$ Simplifying: $$ v^2 = \\frac{G M}{r} $$ The orbital period \\(T\\) is the time taken to complete one orbit: \\[ T = \\frac{2\\pi r}{v} \\] Substituting \\(v\\) : $$ T = 2\\pi r \\sqrt{\\frac{r}{G M}} $$ Squaring both sides: $$ T^2 = \\frac{4\\pi^2 r^3}{G M} $$ Thus, the square of the orbital period is proportional to the cube of the orbital radius: \\[ T^2 \\propto r^3 \\]","title":"1.1 Equations of Motion"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-analysis-of-the-relationship","text":"The larger the orbital radius, the longer the period of revolution. A more massive central body (larger \\(M\\) ) results in shorter orbital periods for a given radius. This relationship is foundational for determining distances and masses in astronomy.","title":"2. Analysis of the Relationship"},{"location":"1%20Physics/2%20Gravity/Problem_1/#3-practical-applications","text":"Satellite Deployment: Designing satellite orbits around Earth or other planets. Planetary Mass Calculation: Determining the mass of celestial bodies by observing their moons. Exoplanet Studies: Finding exoplanets and their orbital characteristics around distant stars.","title":"3. Practical Applications"},{"location":"1%20Physics/2%20Gravity/Problem_1/#4-implementation-python-simulation","text":"The following Python script simulates circular orbits and verifies the relationship between \\(T^2\\) and \\(r^3\\) . import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # gravitational constant (m^3 kg^-1 s^-2) M = 5.972e24 # mass of Earth (kg) # Function to compute orbital period def orbital_period(r): return 2 * np.pi * np.sqrt(r**3 / (G * M)) # Range of orbital radii radii = np.linspace(7e6, 5e7, 100) # from 7000 km to 50000 km (converted to meters) periods = orbital_period(radii) # Plotting T^2 vs r^3 plt.figure(figsize=(8, 5)) plt.plot(radii**3, periods**2, label='T\u00b2 vs r\u00b3') plt.xlabel(\"Orbital Radius Cubed ($r^3$) [m\u00b3]\") plt.ylabel(\"Orbital Period Squared ($T^2$) [s\u00b2]\") plt.title(\"Verification of Kepler's Third Law\") plt.legend() plt.grid() plt.show() # Plotting Orbits theta = np.linspace(0, 2*np.pi, 100) plt.figure(figsize=(8,8)) for r in np.linspace(7e6, 4e7, 5): x = r * np.cos(theta) y = r * np.sin(theta) plt.plot(x, y, label=f'Radius = {r/1000:.0f} km') plt.scatter(0, 0, color='yellow', label='Earth') # Earth at center plt.xlabel(\"x position (m)\") plt.ylabel(\"y position (m)\") plt.title(\"Circular Orbits around Earth\") plt.legend() plt.grid() plt.axis('equal') plt.show()","title":"4. Implementation: Python Simulation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#5-explanation-of-the-graphs","text":"","title":"5. Explanation of the Graphs"},{"location":"1%20Physics/2%20Gravity/Problem_1/#graph-1-t2-vs-r3","text":"This graph demonstrates the linear relationship between the square of the orbital period ( \\(T^2\\) ) and the cube of the orbital radius ( \\(r^3\\) ). As \\(r^3\\) increases, \\(T^2\\) also increases linearly. This verifies Kepler's Third Law for circular orbits.","title":"Graph 1: T\u00b2 vs r\u00b3"},{"location":"1%20Physics/2%20Gravity/Problem_1/#graph-2-visualization-of-orbits","text":"Shows circular orbits for satellites at different radii. Earth is placed at the center. Larger orbital radius corresponds to a larger orbit and a longer period. These visualizations help understand how satellites and moons move around their parent bodies.","title":"Graph 2: Visualization of Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#6-frequently-asked-questions-faq","text":"","title":"6. Frequently Asked Questions (FAQ)"},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-what-does-keplers-third-law-state-for-circular-orbits","text":"It states that the square of the orbital period ( \\(T^2\\) ) is directly proportional to the cube of the orbital radius ( \\(r^3\\) ).","title":"1. What does Kepler's Third Law state for circular orbits?"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-does-the-mass-of-the-satellite-affect-the-orbital-period","text":"No, the satellite's mass cancels out in the equations; only the central mass ( \\(M\\) ) and the orbital radius ( \\(r\\) ) matter.","title":"2. Does the mass of the satellite affect the orbital period?"},{"location":"1%20Physics/2%20Gravity/Problem_1/#3-how-is-this-law-useful-in-real-world-applications","text":"It is used in calculating satellite orbits, determining planetary masses, and studying exoplanets.","title":"3. How is this law useful in real-world applications?"},{"location":"1%20Physics/2%20Gravity/Problem_1/#4-what-happens-if-the-central-bodys-mass-increases","text":"If \\(M\\) increases, the orbital period for a given radius decreases (i.e., objects orbit faster).","title":"4. What happens if the central body's mass increases?"},{"location":"1%20Physics/2%20Gravity/Problem_1/#5-does-this-relationship-apply-to-elliptical-orbits","text":"Yes, but \\(r\\) is replaced with the semi-major axis ( \\(a\\) ) of the ellipse in the general form of Kepler's Third Law.","title":"5. Does this relationship apply to elliptical orbits?"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"","title":"Problem 3"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}