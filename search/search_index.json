{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1: Investigating the Range as a Function of the Angle of Projection 1. Theoretical Foundation Projectile motion is a type of two-dimensional motion where an object is launched into the air with an initial velocity \\(v_0\\) at an angle \\(\\theta\\) relative to the horizontal. The motion can be analyzed by breaking it into horizontal (x) and vertical (y) components. 1.1 Equations of Motion The horizontal and vertical components of the initial velocity are: \\(v_{0x} = v_0 \\cos(\\theta)\\) \\(v_{0y} = v_0 \\sin(\\theta)\\) Using the kinematic equations, the motion in each direction is governed by: - Horizontal motion (constant velocity, no acceleration in the ideal case): \\(x = v_{0x} t = v_0 \\cos(\\theta) t\\) - Vertical motion (accelerated due to gravity): \\(y = v_{0y} t - \\frac{1}{2} g t^2\\) where: \\(g\\) is the acceleration due to gravity \\((9.81 \\text{ m/s}^2)\\) \\(t\\) is the time of flight. 1.2 Time of Flight The time of flight is determined by solving for when the projectile returns to the ground \\((y = 0)\\) : \\(t = \\frac{2 v_0 \\sin(\\theta)}{g}\\) 1.3 Range Equation The range \\(R\\) is the horizontal distance traveled when the projectile lands: \\(R = v_{0x} \\cdot t = v_0 \\cos(\\theta) \\cdot \\frac{2 v_0 \\sin(\\theta)}{g}\\) Using the identity \\(2 \\sin(\\theta) \\cos(\\theta) = \\sin(2\\theta)\\) , we get: \\(R = \\frac{v_0^2 \\sin(2\\theta)}{g}\\) 2. Analysis of the Range The range is maximized when \\(\\sin(2\\theta) = 1\\) , which occurs at \\(2\\theta = 90^\\circ\\) , or \\(\\theta = 45^\\circ\\) . If the initial velocity \\(v_0\\) increases, the range increases quadratically. If gravity \\(g\\) increases (e.g., on another planet), the range decreases. 3. Practical Applications Sports: Understanding projectile motion is crucial in games like soccer, basketball, and golf. Engineering: Used in ballistics, rocketry, and artillery targeting systems. Real-World Effects: Air resistance, wind, and uneven terrain can significantly alter the theoretical range. 4. Implementation: Python Simulation The following Python script simulates projectile motion and plots the range as a function of the angle of projection. import numpy as np import matplotlib.pyplot as plt def projectile_range(v0_l\u0131st, g=9.81): angles = np.linspace(0, 90, 100) # Angle range from 0 to 90 degrees angles_rad = np.radians(angles) # Convert degrees to radians ranges = (v0**2 * np.sin(2 * angles_rad)) / g # Compute range plt.figure(figsize=(8, 5)) plt.plot(angles, ranges, label=f'v0 = {v0} m/s') plt.xlabel(\"Angle (degrees)\") plt.ylabel(\"Range (m)\") plt.title(\"Projectile Range vs. Launch Angle\") plt.legend() plt.grid() plt.show() projectile_range(v0=20) V0=20 V0=45(TOP ONE) Explanation of the Graph This graph illustrates how the horizontal range of a projectile depends on the launch angle for different initial velocities ( \\( v_0 \\) ). Each curve represents a different initial velocity. The maximum range occurs at 45\u00b0 . As the initial velocity increases, the range increases quadratically ( \\( v_0^2 \\) ) . Lower initial velocities result in shorter ranges, while higher velocities allow the projectile to travel further. This helps in understanding how objects like balls, bullets, or rockets behave when launched at different speeds and angles. import numpy as np import matplotlib.pyplot as plt def projectile_range_multi_v0(v0_list, g=9.81): angles = np.linspace(0, 90, 100) angles_rad = np.radians(angles) plt.figure(figsize=(8, 5)) for v0 in v0_list: ranges = (v0**2 * np.sin(2 * angles_rad)) / g plt.plot(angles, ranges, label=f'v0 = {v0} m/s') plt.xlabel(\"Angle (degrees)\") plt.ylabel(\"Range (m)\") plt.title(\"Projectile Range vs. Launch Angle for Different v0\") plt.legend() plt.grid() plt.show() projectile_range_multi_v0([10, 20, 30, 40]) Explanation of the Graph This graph shows how the horizontal range of a projectile changes with the launch angle for different gravitational accelerations ( \\(g\\) ). Each curve represents a different gravitational environment: Earth ( \\(g = 9.81 \\, \\text{m/s}^2\\) ), Moon ( \\(g = 1.62 \\, \\text{m/s}^2\\) ), and Jupiter ( \\(g = 24.79 \\, \\text{m/s}^2\\) ). As gravity decreases (like on the Moon), the range increases for the same initial velocity. On higher gravity bodies (like Jupiter), the range decreases. This graph helps understand how the same projectile behaves differently in various planetary environments. import numpy as np import matplotlib.pyplot as plt def projectile_range_multi_g(v0=20, g_values=[9.81, 1.62, 24.79]): angles = np.linspace(0, 90, 100) angles_rad = np.radians(angles) g_labels = [\"Earth (9.81 m/s\u00b2)\", \"Moon (1.62 m/s\u00b2)\", \"Jupiter (24.79 m/s\u00b2)\"] plt.figure(figsize=(8, 5)) for g, label in zip(g_values, g_labels): ranges = (v0**2 * np.sin(2 * angles_rad)) / g plt.plot(angles, ranges, label=label) plt.xlabel(\"Angle (degrees)\") plt.ylabel(\"Range (m)\") plt.title(\"Projectile Range vs. Launch Angle for Different Gravities\") plt.legend() plt.grid() plt.show() # Example usage projectile_range_multi_g() 5. Frequently Asked Questions (FAQ) 1. At what angle is the maximum range achieved in projectile motion? The maximum range is achieved at 45\u00b0 because, at this angle, the horizontal and vertical components of the velocity are balanced, maximizing distance. 2. How does the initial velocity affect the range? The range increases quadratically (v\u2080\u00b2) as the initial velocity increases, meaning a faster launch gives the projectile more distance to travel. 3. What happens if gravity changes? A higher gravitational acceleration reduces the range because the projectile falls back to the ground more quickly, while a lower gravity increases the range by allowing the projectile to stay in the air longer. 4. Does mass affect the projectile's range? No, in ideal conditions without air resistance, mass does not affect the range because both heavy and light projectiles fall at the same rate under the same conditions. 5. How does air resistance impact projectile motion? Air resistance reduces the range by slowing down the projectile and changing its trajectory, making the optimal launch angle lower than 45\u00b0.","title":"Problem 1: Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1-investigating-the-range-as-a-function-of-the-angle-of-projection","text":"","title":"Problem 1: Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-theoretical-foundation","text":"Projectile motion is a type of two-dimensional motion where an object is launched into the air with an initial velocity \\(v_0\\) at an angle \\(\\theta\\) relative to the horizontal. The motion can be analyzed by breaking it into horizontal (x) and vertical (y) components.","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#11-equations-of-motion","text":"The horizontal and vertical components of the initial velocity are: \\(v_{0x} = v_0 \\cos(\\theta)\\) \\(v_{0y} = v_0 \\sin(\\theta)\\) Using the kinematic equations, the motion in each direction is governed by: - Horizontal motion (constant velocity, no acceleration in the ideal case): \\(x = v_{0x} t = v_0 \\cos(\\theta) t\\) - Vertical motion (accelerated due to gravity): \\(y = v_{0y} t - \\frac{1}{2} g t^2\\) where: \\(g\\) is the acceleration due to gravity \\((9.81 \\text{ m/s}^2)\\) \\(t\\) is the time of flight.","title":"1.1 Equations of Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#12-time-of-flight","text":"The time of flight is determined by solving for when the projectile returns to the ground \\((y = 0)\\) : \\(t = \\frac{2 v_0 \\sin(\\theta)}{g}\\)","title":"1.2 Time of Flight"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#13-range-equation","text":"The range \\(R\\) is the horizontal distance traveled when the projectile lands: \\(R = v_{0x} \\cdot t = v_0 \\cos(\\theta) \\cdot \\frac{2 v_0 \\sin(\\theta)}{g}\\) Using the identity \\(2 \\sin(\\theta) \\cos(\\theta) = \\sin(2\\theta)\\) , we get: \\(R = \\frac{v_0^2 \\sin(2\\theta)}{g}\\)","title":"1.3 Range Equation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-analysis-of-the-range","text":"The range is maximized when \\(\\sin(2\\theta) = 1\\) , which occurs at \\(2\\theta = 90^\\circ\\) , or \\(\\theta = 45^\\circ\\) . If the initial velocity \\(v_0\\) increases, the range increases quadratically. If gravity \\(g\\) increases (e.g., on another planet), the range decreases.","title":"2. Analysis of the Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-practical-applications","text":"Sports: Understanding projectile motion is crucial in games like soccer, basketball, and golf. Engineering: Used in ballistics, rocketry, and artillery targeting systems. Real-World Effects: Air resistance, wind, and uneven terrain can significantly alter the theoretical range.","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-implementation-python-simulation","text":"The following Python script simulates projectile motion and plots the range as a function of the angle of projection. import numpy as np import matplotlib.pyplot as plt def projectile_range(v0_l\u0131st, g=9.81): angles = np.linspace(0, 90, 100) # Angle range from 0 to 90 degrees angles_rad = np.radians(angles) # Convert degrees to radians ranges = (v0**2 * np.sin(2 * angles_rad)) / g # Compute range plt.figure(figsize=(8, 5)) plt.plot(angles, ranges, label=f'v0 = {v0} m/s') plt.xlabel(\"Angle (degrees)\") plt.ylabel(\"Range (m)\") plt.title(\"Projectile Range vs. Launch Angle\") plt.legend() plt.grid() plt.show() projectile_range(v0=20)","title":"4. Implementation: Python Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#v020","text":"","title":"V0=20"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#v045top-one","text":"","title":"V0=45(TOP ONE)"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#explanation-of-the-graph","text":"This graph illustrates how the horizontal range of a projectile depends on the launch angle for different initial velocities ( \\( v_0 \\) ). Each curve represents a different initial velocity. The maximum range occurs at 45\u00b0 . As the initial velocity increases, the range increases quadratically ( \\( v_0^2 \\) ) . Lower initial velocities result in shorter ranges, while higher velocities allow the projectile to travel further. This helps in understanding how objects like balls, bullets, or rockets behave when launched at different speeds and angles. import numpy as np import matplotlib.pyplot as plt def projectile_range_multi_v0(v0_list, g=9.81): angles = np.linspace(0, 90, 100) angles_rad = np.radians(angles) plt.figure(figsize=(8, 5)) for v0 in v0_list: ranges = (v0**2 * np.sin(2 * angles_rad)) / g plt.plot(angles, ranges, label=f'v0 = {v0} m/s') plt.xlabel(\"Angle (degrees)\") plt.ylabel(\"Range (m)\") plt.title(\"Projectile Range vs. Launch Angle for Different v0\") plt.legend() plt.grid() plt.show() projectile_range_multi_v0([10, 20, 30, 40])","title":"Explanation of the Graph"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#explanation-of-the-graph_1","text":"This graph shows how the horizontal range of a projectile changes with the launch angle for different gravitational accelerations ( \\(g\\) ). Each curve represents a different gravitational environment: Earth ( \\(g = 9.81 \\, \\text{m/s}^2\\) ), Moon ( \\(g = 1.62 \\, \\text{m/s}^2\\) ), and Jupiter ( \\(g = 24.79 \\, \\text{m/s}^2\\) ). As gravity decreases (like on the Moon), the range increases for the same initial velocity. On higher gravity bodies (like Jupiter), the range decreases. This graph helps understand how the same projectile behaves differently in various planetary environments. import numpy as np import matplotlib.pyplot as plt def projectile_range_multi_g(v0=20, g_values=[9.81, 1.62, 24.79]): angles = np.linspace(0, 90, 100) angles_rad = np.radians(angles) g_labels = [\"Earth (9.81 m/s\u00b2)\", \"Moon (1.62 m/s\u00b2)\", \"Jupiter (24.79 m/s\u00b2)\"] plt.figure(figsize=(8, 5)) for g, label in zip(g_values, g_labels): ranges = (v0**2 * np.sin(2 * angles_rad)) / g plt.plot(angles, ranges, label=label) plt.xlabel(\"Angle (degrees)\") plt.ylabel(\"Range (m)\") plt.title(\"Projectile Range vs. Launch Angle for Different Gravities\") plt.legend() plt.grid() plt.show() # Example usage projectile_range_multi_g()","title":"Explanation of the Graph"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#5-frequently-asked-questions-faq","text":"","title":"5. Frequently Asked Questions (FAQ)"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-at-what-angle-is-the-maximum-range-achieved-in-projectile-motion","text":"The maximum range is achieved at 45\u00b0 because, at this angle, the horizontal and vertical components of the velocity are balanced, maximizing distance.","title":"1. At what angle is the maximum range achieved in projectile motion?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-how-does-the-initial-velocity-affect-the-range","text":"The range increases quadratically (v\u2080\u00b2) as the initial velocity increases, meaning a faster launch gives the projectile more distance to travel.","title":"2. How does the initial velocity affect the range?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-what-happens-if-gravity-changes","text":"A higher gravitational acceleration reduces the range because the projectile falls back to the ground more quickly, while a lower gravity increases the range by allowing the projectile to stay in the air longer.","title":"3. What happens if gravity changes?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-does-mass-affect-the-projectiles-range","text":"No, in ideal conditions without air resistance, mass does not affect the range because both heavy and light projectiles fall at the same rate under the same conditions.","title":"4. Does mass affect the projectile's range?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#5-how-does-air-resistance-impact-projectile-motion","text":"Air resistance reduces the range by slowing down the projectile and changing its trajectory, making the optimal launch angle lower than 45\u00b0.","title":"5. How does air resistance impact projectile motion?"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Investigating the Dynamics of a Forced Damped Pendulum Motivation The forced damped pendulum is a classic example of nonlinear dynamics. Unlike simple harmonic oscillators, this system responds to periodic external forces and damping, producing rich behavior that includes resonance, synchronization, and even chaos. This kind of system is fundamental in physics and engineering because it mirrors the behavior of real-world systems like suspension bridges, circuits, and mechanical vibration absorbers. 1. Theoretical Foundation The general nonlinear equation for the forced damped pendulum is: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\sin\\theta = A \\cos(\\omega t) \\] Where: - \\(\\theta\\) : angular displacement (radians) - \\(\\gamma\\) : damping coefficient (how quickly oscillations die out) - \\(\\omega_0\\) : natural angular frequency ( \\(\\omega_0 = \\sqrt{g / L}\\) for a pendulum of length \\(L\\) ) - \\(A\\) : amplitude of external force - \\(\\omega\\) : driving frequency Small-Angle Approximation When \\(\\theta\\) is small (typically less than 10\u00b0), we can use the approximation: \\[ \\sin\\theta \\approx \\theta \\] This simplifies the equation to: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = A \\cos(\\omega t) \\] This form is a linear second-order ODE, easier to solve and useful for studying resonance behavior. 2. Python Simulation Let's simulate the pendulum using numerical methods. We'll use the Runge-Kutta method via scipy.integrate.solve_ivp . import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Differential equation def pendulum(t, y, gamma, omega0, A, omega): theta, omega_theta = y dydt = [omega_theta, -gamma * omega_theta - omega0**2 * np.sin(theta) + A * np.cos(omega * t)] return dydt # Parameters gamma = 0.2 omega0 = 1.5 A = 1.2 omega_drive = 2.0 y0 = [0.1, 0.0] t_span = (0, 50) t_eval = np.linspace(*t_span, 5000) # Solve the system sol = solve_ivp(pendulum, t_span, y0, t_eval=t_eval, args=(gamma, omega0, A, omega_drive)) # Plot angle over time plt.figure(figsize=(10, 4)) plt.plot(sol.t, sol.y[0], label='\u03b8(t)') plt.title('Angle vs Time') plt.xlabel('Time (s)') plt.ylabel('Angle (rad)') plt.grid(True) plt.legend() plt.show() 3. Phase Space (\u03b8 vs \u03c9) This plot helps visualize how the system evolves in state space. plt.figure(figsize=(6, 6)) plt.plot(sol.y[0], sol.y[1]) plt.title('Phase Space') plt.xlabel('Angle \u03b8 (rad)') plt.ylabel('Angular Velocity \u03c9 (rad/s)') plt.grid(True) plt.show() 4. Poincar\u00e9 Section The Poincar\u00e9 section samples the system once per driving cycle, helping identify periodicity and chaos. T = 2 * np.pi / omega_drive poincare_times = np.arange(0, t_span[1], T) poincare_points = [] for t_p in poincare_times: idx = np.argmin(np.abs(sol.t - t_p)) poincare_points.append([sol.y[0][idx] % (2*np.pi), sol.y[1][idx]]) poincare_points = np.array(poincare_points) plt.figure(figsize=(6, 6)) plt.scatter(poincare_points[:, 0], poincare_points[:, 1], s=10, color='crimson') plt.title('Poincar\u00e9 Section') plt.xlabel('\u03b8 mod $2\\pi$ (rad)') plt.ylabel('Angular Velocity (rad/s)') plt.grid(True) plt.show() 5. Additional Visualization: Energy Over Time Visualizing total mechanical energy shows how damping and driving force interact. mass = 1.0 length = 1.0 g = 9.81 theta = sol.y[0] omega = sol.y[1] potential_energy = mass * g * length * (1 - np.cos(theta)) kinetic_energy = 0.5 * mass * (length**2) * omega**2 total_energy = potential_energy + kinetic_energy plt.figure(figsize=(10, 4)) plt.plot(sol.t, total_energy) plt.title('Total Mechanical Energy vs Time') plt.xlabel('Time (s)') plt.ylabel('Energy (J)') plt.grid(True) plt.show() 6. Bifurcation Diagram Explore how the long-term behavior changes with the driving amplitude A. bifurcation_A = np.linspace(1.0, 1.5, 300) steady_states = [] for A_val in bifurcation_A: sol = solve_ivp(pendulum, [0, 200], [0.1, 0.0], t_eval=np.linspace(150, 200, 500), args=(gamma, omega0, A_val, omega_drive)) theta_vals = sol.y[0] % (2 * np.pi) steady_states.append((np.full_like(theta_vals, A_val), theta_vals)) plt.figure(figsize=(10, 6)) for A_vals, thetas in steady_states: plt.plot(A_vals, thetas, ',k', alpha=0.5) plt.title(\"Bifurcation Diagram (A vs \u03b8)\") plt.xlabel(\"Driving Amplitude A\") plt.ylabel(\"\u03b8 mod 2\u03c0\") plt.grid(True) plt.show() 7. Lyapunov Exponent Estimation Estimate the largest Lyapunov exponent to determine chaos. def estimate_lyapunov(delta0=1e-8, T_max=100): y1 = np.array([0.1, 0.0]) y2 = y1 + np.array([delta0, 0]) times = np.linspace(0, T_max, 10000) d_list = [] for t in range(len(times) - 1): sol1 = solve_ivp(pendulum, [times[t], times[t+1]], y1, t_eval=[times[t+1]], args=(gamma, omega0, A, omega_drive)) sol2 = solve_ivp(pendulum, [times[t], times[t+1]], y2, t_eval=[times[t+1]], args=(gamma, omega0, A, omega_drive)) y1 = sol1.y[:, -1] y2 = sol2.y[:, -1] delta = np.linalg.norm(y2 - y1) d_list.append(np.log(delta / delta0)) y2 = y1 + delta0 * (y2 - y1) / delta # Renormalize return times[1:], np.cumsum(d_list) / np.arange(1, len(d_list)+1) ltimes, lyap = estimate_lyapunov() plt.figure(figsize=(8, 4)) plt.plot(ltimes, lyap) plt.title(\"Estimated Largest Lyapunov Exponent\") plt.xlabel(\"Time\") plt.ylabel(\"Lyapunov Exponent\") plt.grid(True) plt.show() 8. Exploring Parameters Experimenting with parameters leads to different behaviors: - Increasing A may cause chaotic motion. - Lowering \u03b3 shows less damping, leading to longer sustained oscillations. - Matching \u03c9 with \u03c9\u2080 creates resonance, producing large amplitudes. \ud83d\udd04 Extended Visualization: Adding Forced but Undamped Pendulum This scenario demonstrates periodic motion with sustained energy input and no damping, resulting in regular oscillations without energy loss \u2014 a resonance-friendly setup. We now add the fourth scenario that was previously missing: Case Damping ( \\(b\\) ) Forcing ( \\(A\\) ) Simple Pendulum 0 0 Damped Pendulum 0.5 0 Forced Damped Pendulum 0.5 1.2 Forced (Undamped) Pendulum 0 1.2 \u2705 NEW This configuration shows how the system behaves when it's driven but has no energy loss \u2013 a potentially resonant and unstable regime. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp g = 9.81 L = 1.0 omega0 = np.sqrt(g / L) theta0 = 0.2 omega_init = 0.0 t_span = (0, 30) t_eval = np.linspace(*t_span, 5000) def pendulum_system(t, y, gamma, A, omega_drive): theta, omega = y dtheta_dt = omega domega_dt = -gamma * omega - omega0**2 * np.sin(theta) + A * np.cos(omega_drive * t) return [dtheta_dt, domega_dt] gamma_forced_undamped = 0.0 A_forced = 1.2 omega_drive = 2.0 sol_forced_undamped = solve_ivp(pendulum_system, t_span, [theta0, omega_init], t_eval=t_eval, args=(gamma_forced_undamped, A_forced, omega_drive)) plt.figure(figsize=(12, 5)) plt.subplot(1, 2, 1) plt.plot(sol_forced_undamped.t, sol_forced_undamped.y[0]) plt.title(\"Forced (Undamped) Pendulum: Angle vs Time\") plt.xlabel(\"Time (s)\") plt.ylabel(\"Angle $\\\\theta$ (rad)\") plt.grid(True) plt.subplot(1, 2, 2) plt.plot(sol_forced_undamped.y[0], sol_forced_undamped.y[1]) plt.title(\"Forced (Undamped) Pendulum: Phase Space\") plt.xlabel(\"Angle $\\\\theta$ (rad)\") plt.ylabel(\"Angular Velocity $\\\\omega$ (rad/s)\") plt.grid(True) plt.tight_layout() plt.show() 9. Real-World Applications Energy Harvesters : Pendulums can convert motion into usable energy. Bridge Engineering : Avoiding resonance in suspension bridges is crucial. Washing Machines : Proper damping reduces imbalance. Electronics : RLC circuits have similar equations. Clocks : Pendulum clocks are based on resonance principles. 10. Model Limitations and Extensions The model assumes ideal sine driving forces. Real-world damping is often nonlinear. It doesn't account for multi-dimensional motion. Possible Extensions Add random or non-periodic forcing. Add nonlinear damping (quadratic drag). Study bifurcation diagrams over varying A or \u03c9. Simulate coupled or double pendulums. To fully illustrate the transition from simple to complex dynamics, we add simulations for: Simple Pendulum (no damping, no forcing) Damped Pendulum (with damping, no forcing) Forced Damped Pendulum (already shown above) We simulate and visualize angle-time plots and phase diagrams for the first two to complete the progression. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp g = 9.81 L = 1.0 omega0 = np.sqrt(g / L) theta0 = 0.2 omega_init = 0.0 t_span = (0, 30) t_eval = np.linspace(*t_span, 5000) def pendulum_system(t, y, gamma, A, omega_drive): theta, omega = y dtheta_dt = omega domega_dt = -gamma * omega - omega0**2 * np.sin(theta) + A * np.cos(omega_drive * t) return [dtheta_dt, domega_dt] sol_simple = solve_ivp(pendulum_system, t_span, [theta0, omega_init], t_eval=t_eval, args=(0.0, 0.0, 0.0)) sol_damped = solve_ivp(pendulum_system, t_span, [theta0, omega_init], t_eval=t_eval, args=(0.5, 0.0, 0.0)) plt.figure(figsize=(14, 10)) plt.subplot(2, 2, 1) plt.plot(sol_simple.t, sol_simple.y[0]) plt.title(\"Simple Pendulum: Angle vs Time\") plt.xlabel(\"Time (s)\") plt.ylabel(\"Angle $\\\\theta$ (rad)\") plt.grid(True) plt.subplot(2, 2, 2) plt.plot(sol_simple.y[0], sol_simple.y[1]) plt.title(\"Simple Pendulum: Phase Space\") plt.xlabel(\"Angle $\\\\theta$ (rad)\") plt.ylabel(\"Angular Velocity $\\\\omega$ (rad/s)\") plt.grid(True) plt.subplot(2, 2, 3) plt.plot(sol_damped.t, sol_damped.y[0]) plt.title(\"Damped Pendulum: Angle vs Time\") plt.xlabel(\"Time (s)\") plt.ylabel(\"Angle $\\\\theta$ (rad)\") plt.grid(True) plt.subplot(2, 2, 4) plt.plot(sol_damped.y[0], sol_damped.y[1]) plt.title(\"Damped Pendulum: Phase Space\") plt.xlabel(\"Angle $\\\\theta$ (rad)\") plt.ylabel(\"Angular Velocity $\\\\omega$ (rad/s)\") plt.grid(True) plt.tight_layout() plt.show()","title":"Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#investigating-the-dynamics-of-a-forced-damped-pendulum","text":"","title":"Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#motivation","text":"The forced damped pendulum is a classic example of nonlinear dynamics. Unlike simple harmonic oscillators, this system responds to periodic external forces and damping, producing rich behavior that includes resonance, synchronization, and even chaos. This kind of system is fundamental in physics and engineering because it mirrors the behavior of real-world systems like suspension bridges, circuits, and mechanical vibration absorbers.","title":"Motivation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-theoretical-foundation","text":"The general nonlinear equation for the forced damped pendulum is: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\sin\\theta = A \\cos(\\omega t) \\] Where: - \\(\\theta\\) : angular displacement (radians) - \\(\\gamma\\) : damping coefficient (how quickly oscillations die out) - \\(\\omega_0\\) : natural angular frequency ( \\(\\omega_0 = \\sqrt{g / L}\\) for a pendulum of length \\(L\\) ) - \\(A\\) : amplitude of external force - \\(\\omega\\) : driving frequency","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#small-angle-approximation","text":"When \\(\\theta\\) is small (typically less than 10\u00b0), we can use the approximation: \\[ \\sin\\theta \\approx \\theta \\] This simplifies the equation to: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = A \\cos(\\omega t) \\] This form is a linear second-order ODE, easier to solve and useful for studying resonance behavior.","title":"Small-Angle Approximation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-python-simulation","text":"Let's simulate the pendulum using numerical methods. We'll use the Runge-Kutta method via scipy.integrate.solve_ivp . import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Differential equation def pendulum(t, y, gamma, omega0, A, omega): theta, omega_theta = y dydt = [omega_theta, -gamma * omega_theta - omega0**2 * np.sin(theta) + A * np.cos(omega * t)] return dydt # Parameters gamma = 0.2 omega0 = 1.5 A = 1.2 omega_drive = 2.0 y0 = [0.1, 0.0] t_span = (0, 50) t_eval = np.linspace(*t_span, 5000) # Solve the system sol = solve_ivp(pendulum, t_span, y0, t_eval=t_eval, args=(gamma, omega0, A, omega_drive)) # Plot angle over time plt.figure(figsize=(10, 4)) plt.plot(sol.t, sol.y[0], label='\u03b8(t)') plt.title('Angle vs Time') plt.xlabel('Time (s)') plt.ylabel('Angle (rad)') plt.grid(True) plt.legend() plt.show()","title":"2. Python Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-phase-space-vs","text":"This plot helps visualize how the system evolves in state space. plt.figure(figsize=(6, 6)) plt.plot(sol.y[0], sol.y[1]) plt.title('Phase Space') plt.xlabel('Angle \u03b8 (rad)') plt.ylabel('Angular Velocity \u03c9 (rad/s)') plt.grid(True) plt.show()","title":"3. Phase Space (\u03b8 vs \u03c9)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#_1","text":"","title":""},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-poincare-section","text":"The Poincar\u00e9 section samples the system once per driving cycle, helping identify periodicity and chaos. T = 2 * np.pi / omega_drive poincare_times = np.arange(0, t_span[1], T) poincare_points = [] for t_p in poincare_times: idx = np.argmin(np.abs(sol.t - t_p)) poincare_points.append([sol.y[0][idx] % (2*np.pi), sol.y[1][idx]]) poincare_points = np.array(poincare_points) plt.figure(figsize=(6, 6)) plt.scatter(poincare_points[:, 0], poincare_points[:, 1], s=10, color='crimson') plt.title('Poincar\u00e9 Section') plt.xlabel('\u03b8 mod $2\\pi$ (rad)') plt.ylabel('Angular Velocity (rad/s)') plt.grid(True) plt.show()","title":"4. Poincar\u00e9 Section"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#5-additional-visualization-energy-over-time","text":"Visualizing total mechanical energy shows how damping and driving force interact. mass = 1.0 length = 1.0 g = 9.81 theta = sol.y[0] omega = sol.y[1] potential_energy = mass * g * length * (1 - np.cos(theta)) kinetic_energy = 0.5 * mass * (length**2) * omega**2 total_energy = potential_energy + kinetic_energy plt.figure(figsize=(10, 4)) plt.plot(sol.t, total_energy) plt.title('Total Mechanical Energy vs Time') plt.xlabel('Time (s)') plt.ylabel('Energy (J)') plt.grid(True) plt.show()","title":"5. Additional Visualization: Energy Over Time"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#6-bifurcation-diagram","text":"Explore how the long-term behavior changes with the driving amplitude A. bifurcation_A = np.linspace(1.0, 1.5, 300) steady_states = [] for A_val in bifurcation_A: sol = solve_ivp(pendulum, [0, 200], [0.1, 0.0], t_eval=np.linspace(150, 200, 500), args=(gamma, omega0, A_val, omega_drive)) theta_vals = sol.y[0] % (2 * np.pi) steady_states.append((np.full_like(theta_vals, A_val), theta_vals)) plt.figure(figsize=(10, 6)) for A_vals, thetas in steady_states: plt.plot(A_vals, thetas, ',k', alpha=0.5) plt.title(\"Bifurcation Diagram (A vs \u03b8)\") plt.xlabel(\"Driving Amplitude A\") plt.ylabel(\"\u03b8 mod 2\u03c0\") plt.grid(True) plt.show()","title":"6. Bifurcation Diagram"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#7-lyapunov-exponent-estimation","text":"Estimate the largest Lyapunov exponent to determine chaos. def estimate_lyapunov(delta0=1e-8, T_max=100): y1 = np.array([0.1, 0.0]) y2 = y1 + np.array([delta0, 0]) times = np.linspace(0, T_max, 10000) d_list = [] for t in range(len(times) - 1): sol1 = solve_ivp(pendulum, [times[t], times[t+1]], y1, t_eval=[times[t+1]], args=(gamma, omega0, A, omega_drive)) sol2 = solve_ivp(pendulum, [times[t], times[t+1]], y2, t_eval=[times[t+1]], args=(gamma, omega0, A, omega_drive)) y1 = sol1.y[:, -1] y2 = sol2.y[:, -1] delta = np.linalg.norm(y2 - y1) d_list.append(np.log(delta / delta0)) y2 = y1 + delta0 * (y2 - y1) / delta # Renormalize return times[1:], np.cumsum(d_list) / np.arange(1, len(d_list)+1) ltimes, lyap = estimate_lyapunov() plt.figure(figsize=(8, 4)) plt.plot(ltimes, lyap) plt.title(\"Estimated Largest Lyapunov Exponent\") plt.xlabel(\"Time\") plt.ylabel(\"Lyapunov Exponent\") plt.grid(True) plt.show()","title":"7. Lyapunov Exponent Estimation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#8-exploring-parameters","text":"Experimenting with parameters leads to different behaviors: - Increasing A may cause chaotic motion. - Lowering \u03b3 shows less damping, leading to longer sustained oscillations. - Matching \u03c9 with \u03c9\u2080 creates resonance, producing large amplitudes.","title":"8. Exploring Parameters"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#extended-visualization-adding-forced-but-undamped-pendulum","text":"This scenario demonstrates periodic motion with sustained energy input and no damping, resulting in regular oscillations without energy loss \u2014 a resonance-friendly setup. We now add the fourth scenario that was previously missing: Case Damping ( \\(b\\) ) Forcing ( \\(A\\) ) Simple Pendulum 0 0 Damped Pendulum 0.5 0 Forced Damped Pendulum 0.5 1.2 Forced (Undamped) Pendulum 0 1.2 \u2705 NEW This configuration shows how the system behaves when it's driven but has no energy loss \u2013 a potentially resonant and unstable regime. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp g = 9.81 L = 1.0 omega0 = np.sqrt(g / L) theta0 = 0.2 omega_init = 0.0 t_span = (0, 30) t_eval = np.linspace(*t_span, 5000) def pendulum_system(t, y, gamma, A, omega_drive): theta, omega = y dtheta_dt = omega domega_dt = -gamma * omega - omega0**2 * np.sin(theta) + A * np.cos(omega_drive * t) return [dtheta_dt, domega_dt] gamma_forced_undamped = 0.0 A_forced = 1.2 omega_drive = 2.0 sol_forced_undamped = solve_ivp(pendulum_system, t_span, [theta0, omega_init], t_eval=t_eval, args=(gamma_forced_undamped, A_forced, omega_drive)) plt.figure(figsize=(12, 5)) plt.subplot(1, 2, 1) plt.plot(sol_forced_undamped.t, sol_forced_undamped.y[0]) plt.title(\"Forced (Undamped) Pendulum: Angle vs Time\") plt.xlabel(\"Time (s)\") plt.ylabel(\"Angle $\\\\theta$ (rad)\") plt.grid(True) plt.subplot(1, 2, 2) plt.plot(sol_forced_undamped.y[0], sol_forced_undamped.y[1]) plt.title(\"Forced (Undamped) Pendulum: Phase Space\") plt.xlabel(\"Angle $\\\\theta$ (rad)\") plt.ylabel(\"Angular Velocity $\\\\omega$ (rad/s)\") plt.grid(True) plt.tight_layout() plt.show()","title":"\ud83d\udd04 Extended Visualization: Adding Forced but Undamped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#9-real-world-applications","text":"Energy Harvesters : Pendulums can convert motion into usable energy. Bridge Engineering : Avoiding resonance in suspension bridges is crucial. Washing Machines : Proper damping reduces imbalance. Electronics : RLC circuits have similar equations. Clocks : Pendulum clocks are based on resonance principles.","title":"9. Real-World Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#10-model-limitations-and-extensions","text":"The model assumes ideal sine driving forces. Real-world damping is often nonlinear. It doesn't account for multi-dimensional motion.","title":"10. Model Limitations and Extensions"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#possible-extensions","text":"Add random or non-periodic forcing. Add nonlinear damping (quadratic drag). Study bifurcation diagrams over varying A or \u03c9. Simulate coupled or double pendulums. To fully illustrate the transition from simple to complex dynamics, we add simulations for: Simple Pendulum (no damping, no forcing) Damped Pendulum (with damping, no forcing) Forced Damped Pendulum (already shown above) We simulate and visualize angle-time plots and phase diagrams for the first two to complete the progression. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp g = 9.81 L = 1.0 omega0 = np.sqrt(g / L) theta0 = 0.2 omega_init = 0.0 t_span = (0, 30) t_eval = np.linspace(*t_span, 5000) def pendulum_system(t, y, gamma, A, omega_drive): theta, omega = y dtheta_dt = omega domega_dt = -gamma * omega - omega0**2 * np.sin(theta) + A * np.cos(omega_drive * t) return [dtheta_dt, domega_dt] sol_simple = solve_ivp(pendulum_system, t_span, [theta0, omega_init], t_eval=t_eval, args=(0.0, 0.0, 0.0)) sol_damped = solve_ivp(pendulum_system, t_span, [theta0, omega_init], t_eval=t_eval, args=(0.5, 0.0, 0.0)) plt.figure(figsize=(14, 10)) plt.subplot(2, 2, 1) plt.plot(sol_simple.t, sol_simple.y[0]) plt.title(\"Simple Pendulum: Angle vs Time\") plt.xlabel(\"Time (s)\") plt.ylabel(\"Angle $\\\\theta$ (rad)\") plt.grid(True) plt.subplot(2, 2, 2) plt.plot(sol_simple.y[0], sol_simple.y[1]) plt.title(\"Simple Pendulum: Phase Space\") plt.xlabel(\"Angle $\\\\theta$ (rad)\") plt.ylabel(\"Angular Velocity $\\\\omega$ (rad/s)\") plt.grid(True) plt.subplot(2, 2, 3) plt.plot(sol_damped.t, sol_damped.y[0]) plt.title(\"Damped Pendulum: Angle vs Time\") plt.xlabel(\"Time (s)\") plt.ylabel(\"Angle $\\\\theta$ (rad)\") plt.grid(True) plt.subplot(2, 2, 4) plt.plot(sol_damped.y[0], sol_damped.y[1]) plt.title(\"Damped Pendulum: Phase Space\") plt.xlabel(\"Angle $\\\\theta$ (rad)\") plt.ylabel(\"Angular Velocity $\\\\omega$ (rad/s)\") plt.grid(True) plt.tight_layout() plt.show()","title":"Possible Extensions"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Gravity: Orbital Period and Orbital Radius 1. Introduction and Motivation The relationship between the square of the orbital period ( \\(T^2\\) ) and the cube of the orbital radius ( \\(r^3\\) ) is a cornerstone of celestial mechanics. This fundamental principle, known as Kepler\u2019s Third Law , is crucial for: Understanding planetary motion, Designing satellite trajectories, Calculating masses of celestial bodies, Predicting exoplanet properties. 2. Theoretical Foundation 2.1 Gravitational Force Newton's Law of Universal Gravitation states: \\[ F_{\\text{gravity}} = \\frac{G M m}{r^2} \\] where: - \\(G\\) is the gravitational constant, - \\(M\\) is the mass of the central body, - \\(m\\) is the mass of the orbiting body, - \\(r\\) is the orbital radius. 2.2 Centripetal Force For circular motion, the centripetal force required is: \\[ F_{\\text{centripetal}} = \\frac{m v^2}{r} \\] where \\(v\\) is the orbital speed. 2.3 Orbital Speed Setting gravitational force equal to centripetal force: \\[ \\frac{G M m}{r^2} = \\frac{m v^2}{r} \\] Simplifying: \\[ v^2 = \\frac{G M}{r} \\] Thus, the orbital speed: \\[ v = \\sqrt{\\frac{G M}{r}} \\] 2.4 Orbital Period The orbital period \\(T\\) is the time for one full orbit: \\[ T = \\frac{2 \\pi r}{v} \\] Substituting \\(v\\) : \\[ T = 2 \\pi r \\sqrt{\\frac{r}{G M}} \\] Squaring both sides: \\[ T^2 = \\frac{4 \\pi^2 r^3}{G M} \\] Thus: \\[ T^2 \\propto r^3 \\] 3. Practical Applications in Astronomy 3.1 Determining Planetary Masses Knowing \\(T\\) and \\(r\\) for a satellite, we can rearrange: \\[ M = \\frac{4 \\pi^2 r^3}{G T^2} \\] This is how Earth's mass was first estimated using the Moon! 3.2 Satellite Orbit Design Engineers use \\(T^2 \\propto r^3\\) to calculate satellite orbits for: GPS systems, Communication satellites, Weather monitoring. 3.3 Exoplanet Discovery Detecting periodic star wobble allows astronomers to: Estimate \\(r\\) and \\(T\\) , Infer exoplanet mass, Predict habitable zones. 4. Computational Modeling Let's simulate and visualize these relationships! 4.1 Simulating \\(T^2\\) vs \\(r^3\\) import numpy as np import matplotlib.pyplot as plt G = 6.67430e-11 # m^3 kg^-1 s^-2 M = 5.972e24 # Earth's mass (kg) def orbital_period(r): return 2 * np.pi * np.sqrt(r**3 / (G * M)) radii = np.linspace(7e6, 5e7, 100) periods = orbital_period(radii) plt.figure(figsize=(8, 5)) plt.plot(radii**3, periods**2, color='blue') plt.xlabel(\"Orbital Radius Cubed ($r^3$) [m\u00b3]\") plt.ylabel(\"Orbital Period Squared ($T^2$) [s\u00b2]\") plt.title(\"T\u00b2 vs r\u00b3 - Verification of Kepler's Third Law\") plt.grid() plt.show() Graph 1: T\u00b2 vs r\u00b3 Linear relationship proves Kepler's Third Law. Larger radii mean significantly longer periods. 4.2 Orbital Speed vs Radius speeds = np.sqrt(G * M / radii) plt.figure(figsize=(8, 5)) plt.plot(radii, speeds, color='green') plt.xlabel(\"Orbital Radius ($r$) [m]\") plt.ylabel(\"Orbital Speed ($v$) [m/s]\") plt.title(\"Orbital Speed vs Radius\") plt.grid() plt.show() Graph 2: Orbital Speed vs Radius As \\(r\\) increases, \\(v\\) decreases. Distant orbits move slower! 4.3 Orbital Period vs Radius plt.figure(figsize=(8,5)) plt.plot(radii, periods, color='purple') plt.xlabel(\"Orbital Radius ($r$) [m]\") plt.ylabel(\"Orbital Period ($T$) [s]\") plt.title(\"Orbital Period vs Radius\") plt.grid() plt.show() Graph 3: Orbital Period vs Radius \\(T\\) grows faster than \\(r\\) . Distant satellites have longer periods. 4.4 Different Central Masses masses = [5.972e24, 1.989e30, 1.898e27] labels = ['Earth', 'Sun', 'Jupiter'] plt.figure(figsize=(8,6)) for M_val, label in zip(masses, labels): T = 2 * np.pi * np.sqrt(radii**3 / (G * M_val)) plt.plot(radii, T, label=f'Central Mass: {label}') plt.xlabel(\"Orbital Radius ($r$) [m]\") plt.ylabel(\"Orbital Period ($T$) [s]\") plt.title(\"Orbital Period vs Radius for Different Central Masses\") plt.legend() plt.grid() plt.show() Graph 4: Period for Different Central Masses Larger \\(M\\) leads to shorter \\(T\\) at same \\(r\\) . Sun\u2019s gravity dominates compared to Earth. 4.5 Circular Orbit Visualization theta = np.linspace(0, 2*np.pi, 500) plt.figure(figsize=(8,8)) for r in np.linspace(7e6, 4e7, 5): x = r * np.cos(theta) y = r * np.sin(theta) plt.plot(x, y, label=f'{r/1000:.0f} km orbit') plt.scatter(0, 0, color='yellow', label='Earth') plt.xlabel(\"x (m)\") plt.ylabel(\"y (m)\") plt.title(\"Circular Orbit Visualizations\") plt.axis('equal') plt.grid() plt.legend() plt.show() Graph 5: Circular Orbits Orbit size increases with radius. Earth is at the center! 5. Extension to Elliptical Orbits In elliptical orbits, replace \\(r\\) with semi-major axis \\(a\\) : \\[ T^2 = \\frac{4 \\pi^2 a^3}{G M} \\] Where: \\(a\\) is the semi-major axis, \\(T\\) remains proportional to \\(a^{3/2}\\) . 6. Frequently Asked Questions (FAQ) Q1: Why is \\(T^2 \\propto r^3\\) important? It allows astronomers to estimate masses and distances precisely. Q2: What if the orbit is elliptical? Replace \\(r\\) with \\(a\\) (semi-major axis); \\(T^2 \\propto a^3\\) still holds. Q3: Does mass of orbiting body matter? No, the orbiting mass \\(m\\) cancels out. Q4: How does gravity strength affect period? Stronger gravity (larger \\(M\\) ) shortens the orbital period. Q5: What happens for interstellar objects? In complex multi-body systems, corrections to Kepler\u2019s Law are needed.","title":"Gravity: Orbital Period and Orbital Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#gravity-orbital-period-and-orbital-radius","text":"","title":"Gravity: Orbital Period and Orbital Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-introduction-and-motivation","text":"The relationship between the square of the orbital period ( \\(T^2\\) ) and the cube of the orbital radius ( \\(r^3\\) ) is a cornerstone of celestial mechanics. This fundamental principle, known as Kepler\u2019s Third Law , is crucial for: Understanding planetary motion, Designing satellite trajectories, Calculating masses of celestial bodies, Predicting exoplanet properties.","title":"1. Introduction and Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-theoretical-foundation","text":"","title":"2. Theoretical Foundation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#21-gravitational-force","text":"Newton's Law of Universal Gravitation states: \\[ F_{\\text{gravity}} = \\frac{G M m}{r^2} \\] where: - \\(G\\) is the gravitational constant, - \\(M\\) is the mass of the central body, - \\(m\\) is the mass of the orbiting body, - \\(r\\) is the orbital radius.","title":"2.1 Gravitational Force"},{"location":"1%20Physics/2%20Gravity/Problem_1/#22-centripetal-force","text":"For circular motion, the centripetal force required is: \\[ F_{\\text{centripetal}} = \\frac{m v^2}{r} \\] where \\(v\\) is the orbital speed.","title":"2.2 Centripetal Force"},{"location":"1%20Physics/2%20Gravity/Problem_1/#23-orbital-speed","text":"Setting gravitational force equal to centripetal force: \\[ \\frac{G M m}{r^2} = \\frac{m v^2}{r} \\] Simplifying: \\[ v^2 = \\frac{G M}{r} \\] Thus, the orbital speed: \\[ v = \\sqrt{\\frac{G M}{r}} \\]","title":"2.3 Orbital Speed"},{"location":"1%20Physics/2%20Gravity/Problem_1/#24-orbital-period","text":"The orbital period \\(T\\) is the time for one full orbit: \\[ T = \\frac{2 \\pi r}{v} \\] Substituting \\(v\\) : \\[ T = 2 \\pi r \\sqrt{\\frac{r}{G M}} \\] Squaring both sides: \\[ T^2 = \\frac{4 \\pi^2 r^3}{G M} \\] Thus: \\[ T^2 \\propto r^3 \\]","title":"2.4 Orbital Period"},{"location":"1%20Physics/2%20Gravity/Problem_1/#3-practical-applications-in-astronomy","text":"","title":"3. Practical Applications in Astronomy"},{"location":"1%20Physics/2%20Gravity/Problem_1/#31-determining-planetary-masses","text":"Knowing \\(T\\) and \\(r\\) for a satellite, we can rearrange: \\[ M = \\frac{4 \\pi^2 r^3}{G T^2} \\] This is how Earth's mass was first estimated using the Moon!","title":"3.1 Determining Planetary Masses"},{"location":"1%20Physics/2%20Gravity/Problem_1/#32-satellite-orbit-design","text":"Engineers use \\(T^2 \\propto r^3\\) to calculate satellite orbits for: GPS systems, Communication satellites, Weather monitoring.","title":"3.2 Satellite Orbit Design"},{"location":"1%20Physics/2%20Gravity/Problem_1/#33-exoplanet-discovery","text":"Detecting periodic star wobble allows astronomers to: Estimate \\(r\\) and \\(T\\) , Infer exoplanet mass, Predict habitable zones.","title":"3.3 Exoplanet Discovery"},{"location":"1%20Physics/2%20Gravity/Problem_1/#4-computational-modeling","text":"Let's simulate and visualize these relationships!","title":"4. Computational Modeling"},{"location":"1%20Physics/2%20Gravity/Problem_1/#41-simulating-t2-vs-r3","text":"import numpy as np import matplotlib.pyplot as plt G = 6.67430e-11 # m^3 kg^-1 s^-2 M = 5.972e24 # Earth's mass (kg) def orbital_period(r): return 2 * np.pi * np.sqrt(r**3 / (G * M)) radii = np.linspace(7e6, 5e7, 100) periods = orbital_period(radii) plt.figure(figsize=(8, 5)) plt.plot(radii**3, periods**2, color='blue') plt.xlabel(\"Orbital Radius Cubed ($r^3$) [m\u00b3]\") plt.ylabel(\"Orbital Period Squared ($T^2$) [s\u00b2]\") plt.title(\"T\u00b2 vs r\u00b3 - Verification of Kepler's Third Law\") plt.grid() plt.show()","title":"4.1 Simulating \\(T^2\\) vs \\(r^3\\)"},{"location":"1%20Physics/2%20Gravity/Problem_1/#graph-1-t2-vs-r3","text":"Linear relationship proves Kepler's Third Law. Larger radii mean significantly longer periods.","title":"Graph 1: T\u00b2 vs r\u00b3"},{"location":"1%20Physics/2%20Gravity/Problem_1/#42-orbital-speed-vs-radius","text":"speeds = np.sqrt(G * M / radii) plt.figure(figsize=(8, 5)) plt.plot(radii, speeds, color='green') plt.xlabel(\"Orbital Radius ($r$) [m]\") plt.ylabel(\"Orbital Speed ($v$) [m/s]\") plt.title(\"Orbital Speed vs Radius\") plt.grid() plt.show()","title":"4.2 Orbital Speed vs Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#graph-2-orbital-speed-vs-radius","text":"As \\(r\\) increases, \\(v\\) decreases. Distant orbits move slower!","title":"Graph 2: Orbital Speed vs Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#43-orbital-period-vs-radius","text":"plt.figure(figsize=(8,5)) plt.plot(radii, periods, color='purple') plt.xlabel(\"Orbital Radius ($r$) [m]\") plt.ylabel(\"Orbital Period ($T$) [s]\") plt.title(\"Orbital Period vs Radius\") plt.grid() plt.show()","title":"4.3 Orbital Period vs Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#graph-3-orbital-period-vs-radius","text":"\\(T\\) grows faster than \\(r\\) . Distant satellites have longer periods.","title":"Graph 3: Orbital Period vs Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#44-different-central-masses","text":"masses = [5.972e24, 1.989e30, 1.898e27] labels = ['Earth', 'Sun', 'Jupiter'] plt.figure(figsize=(8,6)) for M_val, label in zip(masses, labels): T = 2 * np.pi * np.sqrt(radii**3 / (G * M_val)) plt.plot(radii, T, label=f'Central Mass: {label}') plt.xlabel(\"Orbital Radius ($r$) [m]\") plt.ylabel(\"Orbital Period ($T$) [s]\") plt.title(\"Orbital Period vs Radius for Different Central Masses\") plt.legend() plt.grid() plt.show()","title":"4.4 Different Central Masses"},{"location":"1%20Physics/2%20Gravity/Problem_1/#graph-4-period-for-different-central-masses","text":"Larger \\(M\\) leads to shorter \\(T\\) at same \\(r\\) . Sun\u2019s gravity dominates compared to Earth.","title":"Graph 4: Period for Different Central Masses"},{"location":"1%20Physics/2%20Gravity/Problem_1/#45-circular-orbit-visualization","text":"theta = np.linspace(0, 2*np.pi, 500) plt.figure(figsize=(8,8)) for r in np.linspace(7e6, 4e7, 5): x = r * np.cos(theta) y = r * np.sin(theta) plt.plot(x, y, label=f'{r/1000:.0f} km orbit') plt.scatter(0, 0, color='yellow', label='Earth') plt.xlabel(\"x (m)\") plt.ylabel(\"y (m)\") plt.title(\"Circular Orbit Visualizations\") plt.axis('equal') plt.grid() plt.legend() plt.show()","title":"4.5 Circular Orbit Visualization"},{"location":"1%20Physics/2%20Gravity/Problem_1/#graph-5-circular-orbits","text":"Orbit size increases with radius. Earth is at the center!","title":"Graph 5: Circular Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#5-extension-to-elliptical-orbits","text":"In elliptical orbits, replace \\(r\\) with semi-major axis \\(a\\) : \\[ T^2 = \\frac{4 \\pi^2 a^3}{G M} \\] Where: \\(a\\) is the semi-major axis, \\(T\\) remains proportional to \\(a^{3/2}\\) .","title":"5. Extension to Elliptical Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#6-frequently-asked-questions-faq","text":"","title":"6. Frequently Asked Questions (FAQ)"},{"location":"1%20Physics/2%20Gravity/Problem_1/#q1-why-is-t2-propto-r3-important","text":"It allows astronomers to estimate masses and distances precisely.","title":"Q1: Why is \\(T^2 \\propto r^3\\) important?"},{"location":"1%20Physics/2%20Gravity/Problem_1/#q2-what-if-the-orbit-is-elliptical","text":"Replace \\(r\\) with \\(a\\) (semi-major axis); \\(T^2 \\propto a^3\\) still holds.","title":"Q2: What if the orbit is elliptical?"},{"location":"1%20Physics/2%20Gravity/Problem_1/#q3-does-mass-of-orbiting-body-matter","text":"No, the orbiting mass \\(m\\) cancels out.","title":"Q3: Does mass of orbiting body matter?"},{"location":"1%20Physics/2%20Gravity/Problem_1/#q4-how-does-gravity-strength-affect-period","text":"Stronger gravity (larger \\(M\\) ) shortens the orbital period.","title":"Q4: How does gravity strength affect period?"},{"location":"1%20Physics/2%20Gravity/Problem_1/#q5-what-happens-for-interstellar-objects","text":"In complex multi-body systems, corrections to Kepler\u2019s Law are needed.","title":"Q5: What happens for interstellar objects?"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2 Escape Velocities and Cosmic Velocities Motivation The concept of escape velocity is fundamental to understanding how an object can overcome the gravitational pull of a celestial body. Extending this idea, the definitions of the first , second , and third cosmic velocities describe thresholds for orbiting a planet, escaping a planet's gravity, and leaving a star system entirely. These principles are crucial for designing satellite launches, planning interplanetary missions, and imagining future interstellar travel. Definitions of Cosmic Velocities First Cosmic Velocity ( \\(v_1\\) ): The minimum velocity needed for a stable circular orbit around a planet without propulsion. Second Cosmic Velocity ( \\(v_2\\) ): The escape velocity \u2014 the minimum velocity needed to break free from a celestial body's gravitational field. Third Cosmic Velocity ( \\(v_3\\) ): The minimum velocity needed to escape the gravitational influence of the star (e.g., the Sun) after escaping the planet. Mathematical Derivations 1. First Cosmic Velocity ( \\(v_1\\) ) Derived by equating the gravitational force to the centripetal force needed for circular motion: \\[ \\frac{GMm}{r^2} = m \\frac{v_1^2}{r} \\] Simplifying: \\[ v_1 = \\sqrt{\\frac{GM}{r}} \\] 2. Second Cosmic Velocity ( \\(v_2\\) ) Derived from energy conservation: kinetic energy must match gravitational potential energy. \\[ \\frac{1}{2}mv_2^2 = \\frac{GMm}{r} \\] Thus: \\[ v_2 = \\sqrt{2} v_1 \\] or \\[ v_2 = \\sqrt{\\frac{2GM}{r}} \\] 3. Third Cosmic Velocity ( \\(v_3\\) ) Requires overcoming the planet's gravity and then escaping the Sun's gravity from Earth's orbit. For approximate calculation: \\[ v_3 \\approx \\sqrt{v_2^2 + v_{esc, Sun}^2} \\] where \\(v_{esc, Sun}\\) is the Sun's escape velocity at the planet's orbital distance. Python Simulation and Visualization We will compute \\(v_1\\) , \\(v_2\\) , and \\(v_3\\) for Earth , Mars , and Jupiter . import numpy as np import matplotlib.pyplot as plt import pandas as pd # Constants G = 6.67430e-11 # Gravitational constant, m^3 kg^-1 s^-2 M_sun = 1.989e30 # Mass of the Sun, kg # Celestial bodies data bodies = { 'Earth': {'mass': 5.972e24, 'radius': 6371e3, 'orbital_radius': 1.496e11}, 'Mars': {'mass': 6.417e23, 'radius': 3389.5e3, 'orbital_radius': 2.279e11}, 'Jupiter': {'mass': 1.898e27, 'radius': 69911e3, 'orbital_radius': 7.785e11} } # Function to calculate velocities def calculate_cosmic_velocities(mass, radius, orbital_radius): v1 = np.sqrt(G * mass / radius) v2 = np.sqrt(2) * v1 v_esc_sun = np.sqrt(2 * G * M_sun / orbital_radius) v3 = np.sqrt(v2**2 + v_esc_sun**2) return v1, v2, v3 # Store results results = {} for body, data in bodies.items(): v1, v2, v3 = calculate_cosmic_velocities(data['mass'], data['radius'], data['orbital_radius']) results[body] = {'mass': data['mass'], 'v1': v1, 'v2': v2, 'v3': v3} # Display results for body, velocities in results.items(): print(f\"{body}: v1 = {velocities['v1']:.2f} m/s, v2 = {velocities['v2']:.2f} m/s, v3 = {velocities['v3']:.2f} m/s\") Earth: v1 = 7909.68 m/s, v2 = 11185.98 m/s, v3 = 43587.65 m/s Mars: v1 = 3554.68 m/s, v2 = 5027.08 m/s, v3 = 34500.32 m/s Jupiter: v1 = 42567.51 m/s, v2 = 60199.54 m/s, v3 = 62968.49 m/s Note: This script calculates the first, second, and third cosmic velocities for Earth, Mars, and Jupiter. Graphical Representations 1. Bar Chart of Cosmic Velocities labels = list(results.keys()) v1_vals = [results[body]['v1'] for body in labels] v2_vals = [results[body]['v2'] for body in labels] v3_vals = [results[body]['v3'] for body in labels] x = np.arange(len(labels)) width = 0.25 fig, ax = plt.subplots(figsize=(10,6)) ax.bar(x - width, v1_vals, width, label='First Cosmic Velocity') ax.bar(x, v2_vals, width, label='Second Cosmic Velocity') ax.bar(x + width, v3_vals, width, label='Third Cosmic Velocity') ax.set_xlabel('Celestial Body') ax.set_ylabel('Velocity (m/s)') ax.set_title('Comparison of Cosmic Velocities') ax.set_xticks(x) ax.set_xticklabels(labels) ax.legend() ax.grid(True) plt.tight_layout() plt.show() 2. Line Plot of Cosmic Velocities plt.figure(figsize=(10,6)) plt.plot(labels, v1_vals, 'o-', label='First Cosmic Velocity') plt.plot(labels, v2_vals, 's-', label='Second Cosmic Velocity') plt.plot(labels, v3_vals, 'd-', label='Third Cosmic Velocity') plt.xlabel('Celestial Body') plt.ylabel('Velocity (m/s)') plt.title('Trends of Cosmic Velocities') plt.legend() plt.grid(True) plt.tight_layout() plt.show() 3. Tabular Summary of Velocities df = pd.DataFrame(results).T[['v1', 'v2', 'v3']] print(df) 4. Log-Log Plot (Mass vs Escape Velocity) mass_vals = [results[body]['mass'] for body in labels] v2_vals = [results[body]['v2'] for body in labels] plt.figure(figsize=(8,6)) plt.loglog(mass_vals, v2_vals, 'o-', markersize=8) plt.xlabel('Mass (kg)') plt.ylabel('Second Cosmic Velocity (m/s)') plt.title('Log-Log Plot: Mass vs Escape Velocity') plt.grid(True, which='both', ls='--') plt.tight_layout() plt.show() 5. Pie Chart (Relative Escape Velocities) plt.figure(figsize=(8,8)) plt.pie(v2_vals, labels=labels, autopct='%1.1f%%', startangle=140) plt.title('Relative Escape Velocities of Planets') plt.tight_layout() plt.show() Importance in Space Exploration First Cosmic Velocity: Required to place satellites into stable orbit. Second Cosmic Velocity: Needed for missions leaving a planet, such as Moon and Mars exploration. Third Cosmic Velocity: Necessary for deep-space missions and interstellar exploration planning. Understanding these velocities informs spacecraft design, mission trajectories, and fuel requirements. Conclusion Escape velocities and cosmic velocities set the fundamental energy thresholds that govern space exploration. Mastery of these concepts has enabled humanity to place satellites in orbit, reach other planets, and imagine future journeys beyond the Solar System. Frequently Asked Questions (FAQ) Q1: Why is the second cosmic velocity higher than the first? Because escaping a planet's gravity requires more energy than simply maintaining a stable orbit. Q2: Why does Jupiter have a much higher escape velocity than Earth? Due to its significantly greater mass and size, creating a stronger gravitational field. Q3: What challenges exist in achieving the third cosmic velocity? The enormous amount of energy and precise navigation needed to escape a star's gravity well. Q4: How are these velocities achieved in practice? Using multi-stage rockets, gravitational assists, and carefully planned launch trajectories. Q5: Are cosmic velocities affected by atmospheres? Yes, atmospheric drag must be overcome, requiring additional velocity beyond the theoretical minimums when launching from planets with atmospheres like Earth.","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#escape-velocities-and-cosmic-velocities","text":"","title":"Escape Velocities and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#motivation","text":"The concept of escape velocity is fundamental to understanding how an object can overcome the gravitational pull of a celestial body. Extending this idea, the definitions of the first , second , and third cosmic velocities describe thresholds for orbiting a planet, escaping a planet's gravity, and leaving a star system entirely. These principles are crucial for designing satellite launches, planning interplanetary missions, and imagining future interstellar travel.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#definitions-of-cosmic-velocities","text":"First Cosmic Velocity ( \\(v_1\\) ): The minimum velocity needed for a stable circular orbit around a planet without propulsion. Second Cosmic Velocity ( \\(v_2\\) ): The escape velocity \u2014 the minimum velocity needed to break free from a celestial body's gravitational field. Third Cosmic Velocity ( \\(v_3\\) ): The minimum velocity needed to escape the gravitational influence of the star (e.g., the Sun) after escaping the planet.","title":"Definitions of Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#mathematical-derivations","text":"","title":"Mathematical Derivations"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1-first-cosmic-velocity-v_1","text":"Derived by equating the gravitational force to the centripetal force needed for circular motion: \\[ \\frac{GMm}{r^2} = m \\frac{v_1^2}{r} \\] Simplifying: \\[ v_1 = \\sqrt{\\frac{GM}{r}} \\]","title":"1. First Cosmic Velocity (\\(v_1\\))"},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-second-cosmic-velocity-v_2","text":"Derived from energy conservation: kinetic energy must match gravitational potential energy. \\[ \\frac{1}{2}mv_2^2 = \\frac{GMm}{r} \\] Thus: \\[ v_2 = \\sqrt{2} v_1 \\] or \\[ v_2 = \\sqrt{\\frac{2GM}{r}} \\]","title":"2. Second Cosmic Velocity (\\(v_2\\))"},{"location":"1%20Physics/2%20Gravity/Problem_2/#3-third-cosmic-velocity-v_3","text":"Requires overcoming the planet's gravity and then escaping the Sun's gravity from Earth's orbit. For approximate calculation: \\[ v_3 \\approx \\sqrt{v_2^2 + v_{esc, Sun}^2} \\] where \\(v_{esc, Sun}\\) is the Sun's escape velocity at the planet's orbital distance.","title":"3. Third Cosmic Velocity (\\(v_3\\))"},{"location":"1%20Physics/2%20Gravity/Problem_2/#python-simulation-and-visualization","text":"We will compute \\(v_1\\) , \\(v_2\\) , and \\(v_3\\) for Earth , Mars , and Jupiter . import numpy as np import matplotlib.pyplot as plt import pandas as pd # Constants G = 6.67430e-11 # Gravitational constant, m^3 kg^-1 s^-2 M_sun = 1.989e30 # Mass of the Sun, kg # Celestial bodies data bodies = { 'Earth': {'mass': 5.972e24, 'radius': 6371e3, 'orbital_radius': 1.496e11}, 'Mars': {'mass': 6.417e23, 'radius': 3389.5e3, 'orbital_radius': 2.279e11}, 'Jupiter': {'mass': 1.898e27, 'radius': 69911e3, 'orbital_radius': 7.785e11} } # Function to calculate velocities def calculate_cosmic_velocities(mass, radius, orbital_radius): v1 = np.sqrt(G * mass / radius) v2 = np.sqrt(2) * v1 v_esc_sun = np.sqrt(2 * G * M_sun / orbital_radius) v3 = np.sqrt(v2**2 + v_esc_sun**2) return v1, v2, v3 # Store results results = {} for body, data in bodies.items(): v1, v2, v3 = calculate_cosmic_velocities(data['mass'], data['radius'], data['orbital_radius']) results[body] = {'mass': data['mass'], 'v1': v1, 'v2': v2, 'v3': v3} # Display results for body, velocities in results.items(): print(f\"{body}: v1 = {velocities['v1']:.2f} m/s, v2 = {velocities['v2']:.2f} m/s, v3 = {velocities['v3']:.2f} m/s\") Earth: v1 = 7909.68 m/s, v2 = 11185.98 m/s, v3 = 43587.65 m/s Mars: v1 = 3554.68 m/s, v2 = 5027.08 m/s, v3 = 34500.32 m/s Jupiter: v1 = 42567.51 m/s, v2 = 60199.54 m/s, v3 = 62968.49 m/s Note: This script calculates the first, second, and third cosmic velocities for Earth, Mars, and Jupiter.","title":"Python Simulation and Visualization"},{"location":"1%20Physics/2%20Gravity/Problem_2/#graphical-representations","text":"","title":"Graphical Representations"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1-bar-chart-of-cosmic-velocities","text":"labels = list(results.keys()) v1_vals = [results[body]['v1'] for body in labels] v2_vals = [results[body]['v2'] for body in labels] v3_vals = [results[body]['v3'] for body in labels] x = np.arange(len(labels)) width = 0.25 fig, ax = plt.subplots(figsize=(10,6)) ax.bar(x - width, v1_vals, width, label='First Cosmic Velocity') ax.bar(x, v2_vals, width, label='Second Cosmic Velocity') ax.bar(x + width, v3_vals, width, label='Third Cosmic Velocity') ax.set_xlabel('Celestial Body') ax.set_ylabel('Velocity (m/s)') ax.set_title('Comparison of Cosmic Velocities') ax.set_xticks(x) ax.set_xticklabels(labels) ax.legend() ax.grid(True) plt.tight_layout() plt.show()","title":"1. Bar Chart of Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-line-plot-of-cosmic-velocities","text":"plt.figure(figsize=(10,6)) plt.plot(labels, v1_vals, 'o-', label='First Cosmic Velocity') plt.plot(labels, v2_vals, 's-', label='Second Cosmic Velocity') plt.plot(labels, v3_vals, 'd-', label='Third Cosmic Velocity') plt.xlabel('Celestial Body') plt.ylabel('Velocity (m/s)') plt.title('Trends of Cosmic Velocities') plt.legend() plt.grid(True) plt.tight_layout() plt.show()","title":"2. Line Plot of Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#3-tabular-summary-of-velocities","text":"df = pd.DataFrame(results).T[['v1', 'v2', 'v3']] print(df)","title":"3. Tabular Summary of Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#4-log-log-plot-mass-vs-escape-velocity","text":"mass_vals = [results[body]['mass'] for body in labels] v2_vals = [results[body]['v2'] for body in labels] plt.figure(figsize=(8,6)) plt.loglog(mass_vals, v2_vals, 'o-', markersize=8) plt.xlabel('Mass (kg)') plt.ylabel('Second Cosmic Velocity (m/s)') plt.title('Log-Log Plot: Mass vs Escape Velocity') plt.grid(True, which='both', ls='--') plt.tight_layout() plt.show()","title":"4. Log-Log Plot (Mass vs Escape Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#5-pie-chart-relative-escape-velocities","text":"plt.figure(figsize=(8,8)) plt.pie(v2_vals, labels=labels, autopct='%1.1f%%', startangle=140) plt.title('Relative Escape Velocities of Planets') plt.tight_layout() plt.show()","title":"5. Pie Chart (Relative Escape Velocities)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#importance-in-space-exploration","text":"First Cosmic Velocity: Required to place satellites into stable orbit. Second Cosmic Velocity: Needed for missions leaving a planet, such as Moon and Mars exploration. Third Cosmic Velocity: Necessary for deep-space missions and interstellar exploration planning. Understanding these velocities informs spacecraft design, mission trajectories, and fuel requirements.","title":"Importance in Space Exploration"},{"location":"1%20Physics/2%20Gravity/Problem_2/#conclusion","text":"Escape velocities and cosmic velocities set the fundamental energy thresholds that govern space exploration. Mastery of these concepts has enabled humanity to place satellites in orbit, reach other planets, and imagine future journeys beyond the Solar System.","title":"Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_2/#frequently-asked-questions-faq","text":"","title":"Frequently Asked Questions (FAQ)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#q1-why-is-the-second-cosmic-velocity-higher-than-the-first","text":"Because escaping a planet's gravity requires more energy than simply maintaining a stable orbit.","title":"Q1: Why is the second cosmic velocity higher than the first?"},{"location":"1%20Physics/2%20Gravity/Problem_2/#q2-why-does-jupiter-have-a-much-higher-escape-velocity-than-earth","text":"Due to its significantly greater mass and size, creating a stronger gravitational field.","title":"Q2: Why does Jupiter have a much higher escape velocity than Earth?"},{"location":"1%20Physics/2%20Gravity/Problem_2/#q3-what-challenges-exist-in-achieving-the-third-cosmic-velocity","text":"The enormous amount of energy and precise navigation needed to escape a star's gravity well.","title":"Q3: What challenges exist in achieving the third cosmic velocity?"},{"location":"1%20Physics/2%20Gravity/Problem_2/#q4-how-are-these-velocities-achieved-in-practice","text":"Using multi-stage rockets, gravitational assists, and carefully planned launch trajectories.","title":"Q4: How are these velocities achieved in practice?"},{"location":"1%20Physics/2%20Gravity/Problem_2/#q5-are-cosmic-velocities-affected-by-atmospheres","text":"Yes, atmospheric drag must be overcome, requiring additional velocity beyond the theoretical minimums when launching from planets with atmospheres like Earth.","title":"Q5: Are cosmic velocities affected by atmospheres?"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3 Trajectories of a Freely Released Payload Near Earth Motivation When an object is released from a moving rocket near Earth, its trajectory depends on initial conditions such as velocity, angle, and altitude. This problem blends principles of orbital mechanics, energy conservation, and numerical simulation. Understanding these trajectories is critical for missions like satellite deployment, reentry modules, or escaping Earth's gravity. Types of Possible Trajectories Depending on the initial velocity ( \\(v_0\\) ) and altitude ( \\(h\\) ), a payload can follow different paths: Elliptical Orbit : \\(v_0\\) < escape velocity; payload remains bound to Earth. Parabolic Trajectory : \\(v_0\\) \u2248 escape velocity; payload barely escapes Earth's gravity. Hyperbolic Trajectory : \\(v_0\\) > escape velocity; payload escapes with excess kinetic energy. Suborbital Trajectory : \\(v_0\\) too low for orbit; payload falls back to Earth. Fundamental Equations Gravitational Force: \\(F = \\frac{GMm}{r^2}\\) Gravitational Potential Energy: \\(U = -\\frac{GMm}{r}\\) Kinetic Energy: \\(K = \\frac{1}{2}mv^2\\) Total Energy (E): \\(E = K + U\\) If \\(E < 0\\) : Elliptical orbit If \\(E = 0\\) : Parabolic trajectory If \\(E > 0\\) : Hyperbolic escape Constants and Initial Setup import numpy as np import matplotlib.pyplot as plt G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M_earth = 5.972e24 # Mass of Earth (kg) R_earth = 6371e3 # Radius of Earth (m) altitude = 300e3 # Payload release altitude (m) r0 = R_earth + altitude v_escape = np.sqrt(2 * G * M_earth / r0) print(f\"Escape velocity at {altitude/1000:.0f} km altitude: {v_escape/1000:.2f} km/s\") Escape velocity at 300 km altitude: 10.93 km/s Note: The escape velocity at the release altitude is printed for reference. Trajectories of Payloads initial_velocities = [0.7 * v_escape, v_escape, 1.2 * v_escape] labels = ['Elliptical Orbit', 'Parabolic Escape', 'Hyperbolic Escape'] dt = 1 # Time step (s) steps = 15000 fig, ax_traj = plt.subplots(figsize=(8,8)) for v0, label in zip(initial_velocities, labels): pos = np.array([r0, 0]) vel = np.array([0, v0]) x_vals, y_vals = [], [] for _ in range(steps): r = np.linalg.norm(pos) acc = -G * M_earth * pos / r**3 vel += acc * dt pos += vel * dt x_vals.append(pos[0]) y_vals.append(pos[1]) if r < R_earth: break ax_traj.plot(x_vals, y_vals, label=label) # Draw Earth theta = np.linspace(0, 2*np.pi, 100) ax_traj.plot(R_earth*np.cos(theta), R_earth*np.sin(theta), 'k') ax_traj.set_aspect('equal') ax_traj.set_xlim(-2e7, 2e7) ax_traj.set_ylim(-2e7, 2e7) ax_traj.set_xlabel('x (m)') ax_traj.set_ylabel('y (m)') ax_traj.set_title('Payload Trajectories') ax_traj.legend() ax_traj.grid() plt.show() Note: This plot shows how different initial speeds result in different types of trajectories. Energy vs Time fig, ax_energy = plt.subplots(figsize=(8,6)) for v0, label in zip(initial_velocities, labels): pos = np.array([r0, 0]) vel = np.array([0, v0]) E_vals, t_vals = [], [] for t in range(steps): r = np.linalg.norm(pos) acc = -G * M_earth * pos / r**3 vel += acc * dt pos += vel * dt energy = 0.5 * np.linalg.norm(vel)**2 - G * M_earth / r E_vals.append(energy) t_vals.append(t * dt) if r < R_earth: break ax_energy.plot(t_vals, E_vals, label=label) ax_energy.set_xlabel('Time (s)') ax_energy.set_ylabel('Specific Energy (J/kg)') ax_energy.set_title('Energy vs Time') ax_energy.legend() ax_energy.grid() plt.show() Note: This plot shows how the total specific energy evolves over time for different cases. Velocity vs Time fig, ax_velocity = plt.subplots(figsize=(8,6)) for v0, label in zip(initial_velocities, labels): pos = np.array([r0, 0]) vel = np.array([0, v0]) v_vals, t_vals = [], [] for t in range(steps): r = np.linalg.norm(pos) acc = -G * M_earth * pos / r**3 vel += acc * dt pos += vel * dt v_vals.append(np.linalg.norm(vel)) t_vals.append(t * dt) if r < R_earth: break ax_velocity.plot(t_vals, v_vals, label=label) ax_velocity.set_xlabel('Time (s)') ax_velocity.set_ylabel('Velocity (m/s)') ax_velocity.set_title('Velocity vs Time') ax_velocity.legend() ax_velocity.grid() plt.show() Note: This plot shows how the payload speed changes with time depending on initial conditions. Distance from Earth vs Time fig, ax_distance = plt.subplots(figsize=(8,6)) for v0, label in zip(initial_velocities, labels): pos = np.array([r0, 0]) vel = np.array([0, v0]) r_vals, t_vals = [], [] for t in range(steps): r = np.linalg.norm(pos) acc = -G * M_earth * pos / r**3 vel += acc * dt pos += vel * dt r_vals.append(r) t_vals.append(t * dt) if r < R_earth: break ax_distance.plot(t_vals, r_vals, label=label) ax_distance.set_xlabel('Time (s)') ax_distance.set_ylabel('Distance from Earth Center (m)') ax_distance.set_title('Distance vs Time') ax_distance.legend() ax_distance.grid() plt.show() Note: This plot shows the distance of the payload from the Earth's center as a function of time. Conclusion Simulating and understanding trajectories for varying initial speeds and angles is essential for modern space missions. From orbital insertions to deep-space escapes, mastering these mechanics is a fundamental part of aerospace engineering. Frequently Asked Questions (FAQ) Q1: Why simulate different angles? Different angles allow payloads to achieve stable orbit, escape, or crash depending on mission needs. Q2: How does energy help classify trajectory type? Total energy being negative, zero, or positive immediately tells whether the motion is elliptical, parabolic, or hyperbolic. Q3: Can air resistance be included? Yes, adding atmospheric drag would make the simulation more realistic but more complex. Q4: Why does velocity decrease after release? Gravitational pull reduces upward velocity; depending on initial speed, the payload may orbit, escape, or fall. Q5: How accurate is Euler's method here? For small enough time steps ( \\(\\Delta t\\) ), it gives reasonably accurate approximations, but better methods exist (e.g., Runge-Kutta 4th order).","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#trajectories-of-a-freely-released-payload-near-earth","text":"","title":"Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#motivation","text":"When an object is released from a moving rocket near Earth, its trajectory depends on initial conditions such as velocity, angle, and altitude. This problem blends principles of orbital mechanics, energy conservation, and numerical simulation. Understanding these trajectories is critical for missions like satellite deployment, reentry modules, or escaping Earth's gravity.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#types-of-possible-trajectories","text":"Depending on the initial velocity ( \\(v_0\\) ) and altitude ( \\(h\\) ), a payload can follow different paths: Elliptical Orbit : \\(v_0\\) < escape velocity; payload remains bound to Earth. Parabolic Trajectory : \\(v_0\\) \u2248 escape velocity; payload barely escapes Earth's gravity. Hyperbolic Trajectory : \\(v_0\\) > escape velocity; payload escapes with excess kinetic energy. Suborbital Trajectory : \\(v_0\\) too low for orbit; payload falls back to Earth.","title":"Types of Possible Trajectories"},{"location":"1%20Physics/2%20Gravity/Problem_3/#fundamental-equations","text":"Gravitational Force: \\(F = \\frac{GMm}{r^2}\\) Gravitational Potential Energy: \\(U = -\\frac{GMm}{r}\\) Kinetic Energy: \\(K = \\frac{1}{2}mv^2\\) Total Energy (E): \\(E = K + U\\) If \\(E < 0\\) : Elliptical orbit If \\(E = 0\\) : Parabolic trajectory If \\(E > 0\\) : Hyperbolic escape","title":"Fundamental Equations"},{"location":"1%20Physics/2%20Gravity/Problem_3/#constants-and-initial-setup","text":"import numpy as np import matplotlib.pyplot as plt G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M_earth = 5.972e24 # Mass of Earth (kg) R_earth = 6371e3 # Radius of Earth (m) altitude = 300e3 # Payload release altitude (m) r0 = R_earth + altitude v_escape = np.sqrt(2 * G * M_earth / r0) print(f\"Escape velocity at {altitude/1000:.0f} km altitude: {v_escape/1000:.2f} km/s\") Escape velocity at 300 km altitude: 10.93 km/s Note: The escape velocity at the release altitude is printed for reference.","title":"Constants and Initial Setup"},{"location":"1%20Physics/2%20Gravity/Problem_3/#trajectories-of-payloads","text":"initial_velocities = [0.7 * v_escape, v_escape, 1.2 * v_escape] labels = ['Elliptical Orbit', 'Parabolic Escape', 'Hyperbolic Escape'] dt = 1 # Time step (s) steps = 15000 fig, ax_traj = plt.subplots(figsize=(8,8)) for v0, label in zip(initial_velocities, labels): pos = np.array([r0, 0]) vel = np.array([0, v0]) x_vals, y_vals = [], [] for _ in range(steps): r = np.linalg.norm(pos) acc = -G * M_earth * pos / r**3 vel += acc * dt pos += vel * dt x_vals.append(pos[0]) y_vals.append(pos[1]) if r < R_earth: break ax_traj.plot(x_vals, y_vals, label=label) # Draw Earth theta = np.linspace(0, 2*np.pi, 100) ax_traj.plot(R_earth*np.cos(theta), R_earth*np.sin(theta), 'k') ax_traj.set_aspect('equal') ax_traj.set_xlim(-2e7, 2e7) ax_traj.set_ylim(-2e7, 2e7) ax_traj.set_xlabel('x (m)') ax_traj.set_ylabel('y (m)') ax_traj.set_title('Payload Trajectories') ax_traj.legend() ax_traj.grid() plt.show() Note: This plot shows how different initial speeds result in different types of trajectories.","title":"Trajectories of Payloads"},{"location":"1%20Physics/2%20Gravity/Problem_3/#energy-vs-time","text":"fig, ax_energy = plt.subplots(figsize=(8,6)) for v0, label in zip(initial_velocities, labels): pos = np.array([r0, 0]) vel = np.array([0, v0]) E_vals, t_vals = [], [] for t in range(steps): r = np.linalg.norm(pos) acc = -G * M_earth * pos / r**3 vel += acc * dt pos += vel * dt energy = 0.5 * np.linalg.norm(vel)**2 - G * M_earth / r E_vals.append(energy) t_vals.append(t * dt) if r < R_earth: break ax_energy.plot(t_vals, E_vals, label=label) ax_energy.set_xlabel('Time (s)') ax_energy.set_ylabel('Specific Energy (J/kg)') ax_energy.set_title('Energy vs Time') ax_energy.legend() ax_energy.grid() plt.show() Note: This plot shows how the total specific energy evolves over time for different cases.","title":"Energy vs Time"},{"location":"1%20Physics/2%20Gravity/Problem_3/#velocity-vs-time","text":"fig, ax_velocity = plt.subplots(figsize=(8,6)) for v0, label in zip(initial_velocities, labels): pos = np.array([r0, 0]) vel = np.array([0, v0]) v_vals, t_vals = [], [] for t in range(steps): r = np.linalg.norm(pos) acc = -G * M_earth * pos / r**3 vel += acc * dt pos += vel * dt v_vals.append(np.linalg.norm(vel)) t_vals.append(t * dt) if r < R_earth: break ax_velocity.plot(t_vals, v_vals, label=label) ax_velocity.set_xlabel('Time (s)') ax_velocity.set_ylabel('Velocity (m/s)') ax_velocity.set_title('Velocity vs Time') ax_velocity.legend() ax_velocity.grid() plt.show() Note: This plot shows how the payload speed changes with time depending on initial conditions.","title":"Velocity vs Time"},{"location":"1%20Physics/2%20Gravity/Problem_3/#distance-from-earth-vs-time","text":"fig, ax_distance = plt.subplots(figsize=(8,6)) for v0, label in zip(initial_velocities, labels): pos = np.array([r0, 0]) vel = np.array([0, v0]) r_vals, t_vals = [], [] for t in range(steps): r = np.linalg.norm(pos) acc = -G * M_earth * pos / r**3 vel += acc * dt pos += vel * dt r_vals.append(r) t_vals.append(t * dt) if r < R_earth: break ax_distance.plot(t_vals, r_vals, label=label) ax_distance.set_xlabel('Time (s)') ax_distance.set_ylabel('Distance from Earth Center (m)') ax_distance.set_title('Distance vs Time') ax_distance.legend() ax_distance.grid() plt.show() Note: This plot shows the distance of the payload from the Earth's center as a function of time.","title":"Distance from Earth vs Time"},{"location":"1%20Physics/2%20Gravity/Problem_3/#conclusion","text":"Simulating and understanding trajectories for varying initial speeds and angles is essential for modern space missions. From orbital insertions to deep-space escapes, mastering these mechanics is a fundamental part of aerospace engineering.","title":"Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_3/#frequently-asked-questions-faq","text":"","title":"Frequently Asked Questions (FAQ)"},{"location":"1%20Physics/2%20Gravity/Problem_3/#q1-why-simulate-different-angles","text":"Different angles allow payloads to achieve stable orbit, escape, or crash depending on mission needs.","title":"Q1: Why simulate different angles?"},{"location":"1%20Physics/2%20Gravity/Problem_3/#q2-how-does-energy-help-classify-trajectory-type","text":"Total energy being negative, zero, or positive immediately tells whether the motion is elliptical, parabolic, or hyperbolic.","title":"Q2: How does energy help classify trajectory type?"},{"location":"1%20Physics/2%20Gravity/Problem_3/#q3-can-air-resistance-be-included","text":"Yes, adding atmospheric drag would make the simulation more realistic but more complex.","title":"Q3: Can air resistance be included?"},{"location":"1%20Physics/2%20Gravity/Problem_3/#q4-why-does-velocity-decrease-after-release","text":"Gravitational pull reduces upward velocity; depending on initial speed, the payload may orbit, escape, or fall.","title":"Q4: Why does velocity decrease after release?"},{"location":"1%20Physics/2%20Gravity/Problem_3/#q5-how-accurate-is-eulers-method-here","text":"For small enough time steps ( \\(\\Delta t\\) ), it gives reasonably accurate approximations, but better methods exist (e.g., Runge-Kutta 4th order).","title":"Q5: How accurate is Euler's method here?"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem: Circular Wave Interference from Multiple Sources Motivation Interference on a water surface provides a beautiful, tangible example of how waves interact. By studying these patterns from coherent point sources arranged in a regular polygon, we can observe and analyze wave superposition, constructive interference (bright spots), and destructive interference (dark spots). Assumptions and Parameters All sources emit circular waves. Same amplitude \\[ A \\] , wavelength $$ \\lambda $$ , and frequency $$ f $$ . - The phase is constant across all sources. Physical Background When multiple point sources emit circular waves in phase, the overlapping of these waves leads to constructive and destructive interference. The wave pattern on the water surface can be predicted by summing the displacements from each source using the principle of superposition . Each point source at location \\((x_i, y_i)\\) produces a wave: \\[ \\eta_i(x, y, t) = \\frac{A}{\\sqrt{r_i}} \\cos(k r_i - \\omega t + \\phi) \\] Where: - \\(A\\) is the amplitude of the wave - \\(r_i = \\sqrt{(x - x_i)^2 + (y - y_i)^2}\\) is the distance to the observation point - \\(k = \\frac{2\\pi}{\\lambda}\\) is the wavenumber - \\(\\omega = 2\\pi f\\) is the angular frequency - \\(\\phi\\) is the initial phase (assumed to be zero unless otherwise specified) The total wave at point \\((x, y)\\) and time \\(t\\) is: \\[ \\eta(x, y, t) = \\sum_{i=1}^{N} \\eta_i(x, y, t) \\] Parameters and Setup We consider: - \\(N = 6\\) sources arranged at the vertices of a regular hexagon - Constant amplitude \\(A = 1.0\\) - Wavelength \\(\\lambda = 1.0\\) - Frequency \\(f = 1.0\\) Hz - Time snapshot at \\(t = 0\\) Imports and Configuration import numpy as np import matplotlib.pyplot as plt Observations Constructive Interference : Regions where waves add (bright colors). Destructive Interference : Regions where waves cancel (dark colors). Symmetry : The pattern reflects the symmetry of the polygon. Try changing N to 3 (triangle), 4 (square), or more to explore different polygon arrangements. Conclusion This simulation shows how coherent sources produce rich interference patterns. The configuration of the sources determines the spatial frequency and symmetry of the interference. Such analyses are useful in acoustics, optics, and wave physics in general. import numpy as np import matplotlib.pyplot as plt # Dalga parametreleri A = 1.0 wavelength = 1.0 k = 2 * np.pi / wavelength omega = 2 * np.pi phi = 0 t = 0.0 # Grid tan\u0131m\u0131 x = np.linspace(-5, 5, 500) y = np.linspace(-5, 5, 500) X, Y = np.meshgrid(x, y) # Kaynaklar\u0131n yer alaca\u011f\u0131 dairenin yar\u0131\u00e7ap\u0131 radius = 2.0 # Kaynaklar\u0131 \u00fcret def generate_sources(N): if N == 1: return [(0, 0)] # Tek kaynak merkezde elif N == 2: return [(-radius / 2, 0), (radius / 2, 0)] # \u0130ki kaynak yatay eksende else: raise ValueError(\"Bu s\u00fcr\u00fcm sadece N=1 ve N=2 i\u00e7indir.\") # Giri\u015fim desenini \u00e7iz def plot_pattern(N): sources = generate_sources(N) Z = np.zeros_like(X) for sx, sy in sources: r = np.sqrt((X - sx)**2 + (Y - sy)**2) Z += A * np.sin(k * r - omega * t + phi) plt.figure(figsize=(6, 6)) plt.contourf(X, Y, Z, levels=100, cmap='seismic') # Kaynaklar\u0131 siyah noktalarla \u00e7iz for sx, sy in sources: plt.plot(sx, sy, 'ko') plt.title(f'{N} Noktal\u0131 Kaynak Giri\u015fimi') plt.xlabel('x') plt.ylabel('y') plt.axis('equal') plt.colorbar(label='Dalga Yer De\u011fi\u015fimi') plt.grid(True) plt.show() # Yaln\u0131zca N = 1 ve N = 2 durumlar\u0131 i\u00e7in \u00e7izim for N in [1, 2]: plot_pattern(N) import numpy as np import matplotlib.pyplot as plt # Parameters A = 1.0 wavelength = 1.0 k = 2 * np.pi / wavelength omega = 2 * np.pi phi = 0 t = 0.0 x = np.linspace(-5, 5, 500) y = np.linspace(-5, 5, 500) X, Y = np.meshgrid(x, y) radius = 2.0 def generate_polygon_sources(N, radius): angles = np.linspace(0, 2 * np.pi, N, endpoint=False) return [(radius * np.cos(a), radius * np.sin(a)) for a in angles] def plot_pattern(N): sources = generate_polygon_sources(N, radius) Z = np.zeros_like(X) for sx, sy in sources: r = np.sqrt((X - sx)**2 + (Y - sy)**2) Z += A * np.sin(k * r - omega * t + phi) plt.figure(figsize=(6, 6)) plt.contourf(X, Y, Z, levels=100, cmap='seismic') for sx, sy in sources: plt.plot(sx, sy, 'ko') plt.title(f'{N}-Point Source Interference') plt.xlabel('x') plt.ylabel('y') plt.axis('equal') plt.colorbar(label='Wave Displacement') plt.grid(True) plt.show() # Triangle, Square, Pentagon for N in [3, 4, 5]: plot_pattern(N) from mpl_toolkits.mplot3d import Axes3D def plot_3d_surface(N): sources = generate_polygon_sources(N, radius) Z = np.zeros_like(X) for sx, sy in sources: r = np.sqrt((X - sx)**2 + (Y - sy)**2) Z += A * np.sin(k * r - omega * t + phi) fig = plt.figure(figsize=(10, 6)) ax = fig.add_subplot(111, projection='3d') ax.plot_surface(X, Y, Z, cmap='viridis', edgecolor='none') ax.set_title(f'3D Interference Surface ({N} Sources)') ax.set_xlabel('x') ax.set_ylabel('y') ax.set_zlabel('Amplitude') plt.show() # Show 3D patternn for pentagon plot_3d_surface(5)","title":"Problem: Circular Wave Interference from Multiple Sources"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-circular-wave-interference-from-multiple-sources","text":"","title":"Problem: Circular Wave Interference from Multiple Sources"},{"location":"1%20Physics/3%20Waves/Problem_1/#motivation","text":"Interference on a water surface provides a beautiful, tangible example of how waves interact. By studying these patterns from coherent point sources arranged in a regular polygon, we can observe and analyze wave superposition, constructive interference (bright spots), and destructive interference (dark spots).","title":"Motivation"},{"location":"1%20Physics/3%20Waves/Problem_1/#assumptions-and-parameters","text":"All sources emit circular waves. Same amplitude \\[ A \\] , wavelength $$ \\lambda $$ , and frequency $$ f $$ . - The phase is constant across all sources.","title":"Assumptions and Parameters"},{"location":"1%20Physics/3%20Waves/Problem_1/#physical-background","text":"When multiple point sources emit circular waves in phase, the overlapping of these waves leads to constructive and destructive interference. The wave pattern on the water surface can be predicted by summing the displacements from each source using the principle of superposition . Each point source at location \\((x_i, y_i)\\) produces a wave: \\[ \\eta_i(x, y, t) = \\frac{A}{\\sqrt{r_i}} \\cos(k r_i - \\omega t + \\phi) \\] Where: - \\(A\\) is the amplitude of the wave - \\(r_i = \\sqrt{(x - x_i)^2 + (y - y_i)^2}\\) is the distance to the observation point - \\(k = \\frac{2\\pi}{\\lambda}\\) is the wavenumber - \\(\\omega = 2\\pi f\\) is the angular frequency - \\(\\phi\\) is the initial phase (assumed to be zero unless otherwise specified) The total wave at point \\((x, y)\\) and time \\(t\\) is: \\[ \\eta(x, y, t) = \\sum_{i=1}^{N} \\eta_i(x, y, t) \\]","title":"Physical Background"},{"location":"1%20Physics/3%20Waves/Problem_1/#parameters-and-setup","text":"We consider: - \\(N = 6\\) sources arranged at the vertices of a regular hexagon - Constant amplitude \\(A = 1.0\\) - Wavelength \\(\\lambda = 1.0\\) - Frequency \\(f = 1.0\\) Hz - Time snapshot at \\(t = 0\\)","title":"Parameters and Setup"},{"location":"1%20Physics/3%20Waves/Problem_1/#imports-and-configuration","text":"import numpy as np import matplotlib.pyplot as plt","title":"Imports and Configuration"},{"location":"1%20Physics/3%20Waves/Problem_1/#observations","text":"Constructive Interference : Regions where waves add (bright colors). Destructive Interference : Regions where waves cancel (dark colors). Symmetry : The pattern reflects the symmetry of the polygon. Try changing N to 3 (triangle), 4 (square), or more to explore different polygon arrangements.","title":"Observations"},{"location":"1%20Physics/3%20Waves/Problem_1/#conclusion","text":"This simulation shows how coherent sources produce rich interference patterns. The configuration of the sources determines the spatial frequency and symmetry of the interference. Such analyses are useful in acoustics, optics, and wave physics in general. import numpy as np import matplotlib.pyplot as plt # Dalga parametreleri A = 1.0 wavelength = 1.0 k = 2 * np.pi / wavelength omega = 2 * np.pi phi = 0 t = 0.0 # Grid tan\u0131m\u0131 x = np.linspace(-5, 5, 500) y = np.linspace(-5, 5, 500) X, Y = np.meshgrid(x, y) # Kaynaklar\u0131n yer alaca\u011f\u0131 dairenin yar\u0131\u00e7ap\u0131 radius = 2.0 # Kaynaklar\u0131 \u00fcret def generate_sources(N): if N == 1: return [(0, 0)] # Tek kaynak merkezde elif N == 2: return [(-radius / 2, 0), (radius / 2, 0)] # \u0130ki kaynak yatay eksende else: raise ValueError(\"Bu s\u00fcr\u00fcm sadece N=1 ve N=2 i\u00e7indir.\") # Giri\u015fim desenini \u00e7iz def plot_pattern(N): sources = generate_sources(N) Z = np.zeros_like(X) for sx, sy in sources: r = np.sqrt((X - sx)**2 + (Y - sy)**2) Z += A * np.sin(k * r - omega * t + phi) plt.figure(figsize=(6, 6)) plt.contourf(X, Y, Z, levels=100, cmap='seismic') # Kaynaklar\u0131 siyah noktalarla \u00e7iz for sx, sy in sources: plt.plot(sx, sy, 'ko') plt.title(f'{N} Noktal\u0131 Kaynak Giri\u015fimi') plt.xlabel('x') plt.ylabel('y') plt.axis('equal') plt.colorbar(label='Dalga Yer De\u011fi\u015fimi') plt.grid(True) plt.show() # Yaln\u0131zca N = 1 ve N = 2 durumlar\u0131 i\u00e7in \u00e7izim for N in [1, 2]: plot_pattern(N) import numpy as np import matplotlib.pyplot as plt # Parameters A = 1.0 wavelength = 1.0 k = 2 * np.pi / wavelength omega = 2 * np.pi phi = 0 t = 0.0 x = np.linspace(-5, 5, 500) y = np.linspace(-5, 5, 500) X, Y = np.meshgrid(x, y) radius = 2.0 def generate_polygon_sources(N, radius): angles = np.linspace(0, 2 * np.pi, N, endpoint=False) return [(radius * np.cos(a), radius * np.sin(a)) for a in angles] def plot_pattern(N): sources = generate_polygon_sources(N, radius) Z = np.zeros_like(X) for sx, sy in sources: r = np.sqrt((X - sx)**2 + (Y - sy)**2) Z += A * np.sin(k * r - omega * t + phi) plt.figure(figsize=(6, 6)) plt.contourf(X, Y, Z, levels=100, cmap='seismic') for sx, sy in sources: plt.plot(sx, sy, 'ko') plt.title(f'{N}-Point Source Interference') plt.xlabel('x') plt.ylabel('y') plt.axis('equal') plt.colorbar(label='Wave Displacement') plt.grid(True) plt.show() # Triangle, Square, Pentagon for N in [3, 4, 5]: plot_pattern(N) from mpl_toolkits.mplot3d import Axes3D def plot_3d_surface(N): sources = generate_polygon_sources(N, radius) Z = np.zeros_like(X) for sx, sy in sources: r = np.sqrt((X - sx)**2 + (Y - sy)**2) Z += A * np.sin(k * r - omega * t + phi) fig = plt.figure(figsize=(10, 6)) ax = fig.add_subplot(111, projection='3d') ax.plot_surface(X, Y, Z, cmap='viridis', edgecolor='none') ax.set_title(f'3D Interference Surface ({N} Sources)') ax.set_xlabel('x') ax.set_ylabel('y') ax.set_zlabel('Amplitude') plt.show() # Show 3D patternn for pentagon plot_3d_surface(5)","title":"Conclusion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1 Simulating the Effects of the Lorentz Force Motivation The Lorentz force plays a fundamental role in electromagnetism, governing the motion of charged particles in electric and magnetic fields. Understanding this force is crucial in applications like particle accelerators, mass spectrometers, and plasma confinement systems. Key Equations The Lorentz force equation is: \\[ \\vec{F} = q(\\vec{E} + \\vec{v} \\times \\vec{B}) \\] Where: \\( q \\) = charge of the particle \\( \\vec{E} \\) = electric field \\( \\vec{B} \\) = magnetic field \\( \\vec{v} \\) = velocity of the particle Simulation Parameters import numpy as np import matplotlib.pyplot as plt # === Particle and Field Parameters === q = 1.0 # Charge (C) m = 1.0 # Mass (kg) E = np.array([0.0, 0.0, 0.0]) # Electric field (V/m) B = np.array([0.0, 0.0, 1.0]) # Magnetic field (T) # === Initial Conditions === r = np.array([0.0, 0.0, 0.0]) # Position (m) v = np.array([1.0, 0.0, 0.0]) # Velocity (m/s) # === Time Setup === dt = 0.01 # Time step (s) T = 20 # Total time (s) N = int(T / dt) # === Data Storage for Trajectory === trajectory = np.zeros((N, 3)) time = np.linspace(0, T, N) # === Simulation Loop === for i in range(N): # Save current position trajectory[i] = r # Lorentz force: F = q(E + v \u00d7 B) force = q * (E + np.cross(v, B)) # Acceleration a = force / m # Euler integration (can upgrade to Runge-Kutta for higher accuracy) v += a * dt r += v * dt # === Plotting the Trajectory in XY Plane === plt.figure(figsize=(6, 6)) plt.plot(trajectory[:, 0], trajectory[:, 1], label='Trajectory') plt.xlabel('x (m)') plt.ylabel('y (m)') plt.title('Charged Particle in Magnetic Field (Circular Motion)') plt.grid(True) plt.axis('equal') plt.legend() plt.show() Observations and Physical Insight Circular motion : Occurs when only a magnetic field is present and the initial velocity is perpendicular to the field. Helical motion : Results from a velocity component both parallel and perpendicular to the magnetic field. Drift motion : Emerges when electric and magnetic fields are crossed. Larmor Radius: \\[ r_L = \\frac{mv_\\perp}{qB} \\] Cyclotron Frequency: \\[ \\omega_c = \\frac{qB}{m} \\] Extensions Add non-uniform magnetic fields. Include relativistic corrections . Simulate plasma behavior with multiple particles. Conclusion This simulation gives insight into the fundamental behavior of charged particles under electromagnetic influence. Real-world applications span from fusion reactors to space plasma dynamics and particle beam control in accelerators. import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Parameters q = 1.0 # charge m = 1.0 # mass B = np.array([0, 0, 1.0]) # uniform magnetic field E = np.array([0, 0, 0]) # no electric field v0 = np.array([1.0, 0.0, 1.0]) # velocity with component along B r0 = np.array([0.0, 0.0, 0.0]) dt = 0.01 T = 20 N = int(T / dt) # Arrays r = np.zeros((N, 3)) v = np.zeros((N, 3)) r[0], v[0] = r0, v0 def lorentz_force(v, E, B): return q * (E + np.cross(v, B)) # Integrate using Euler method for i in range(1, N): a = lorentz_force(v[i-1], E, B) / m v[i] = v[i-1] + a * dt r[i] = r[i-1] + v[i] * dt # 3D Plot fig = plt.figure(figsize=(10,6)) ax = fig.add_subplot(111, projection='3d') ax.plot(r[:,0], r[:,1], r[:,2]) ax.set_title('Helical Motion of a Charged Particle') ax.set_xlabel('X') ax.set_ylabel('Y') ax.set_zlabel('Z') plt.show() # Crossed fields: E in x-direction, B in z-direction E = np.array([1.0, 0.0, 0.0]) B = np.array([0.0, 0.0, 1.0]) v0 = np.array([0.0, 1.0, 0.0]) # initial velocity # Reinitialize r = np.zeros((N, 3)) v = np.zeros((N, 3)) r[0], v[0] = r0, v0 for i in range(1, N): a = lorentz_force(v[i-1], E, B) / m v[i] = v[i-1] + a * dt r[i] = r[i-1] + v[i] * dt # 2D Plot of Drift plt.figure(figsize=(8,6)) plt.plot(r[:,0], r[:,1]) plt.title('Drift Motion in Crossed Electric and Magnetic Fields') plt.xlabel('X') plt.ylabel('Y') plt.axis('equal') plt.grid(True) plt.show()","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#simulating-the-effects-of-the-lorentz-force","text":"","title":"Simulating the Effects of the Lorentz Force"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#motivation","text":"The Lorentz force plays a fundamental role in electromagnetism, governing the motion of charged particles in electric and magnetic fields. Understanding this force is crucial in applications like particle accelerators, mass spectrometers, and plasma confinement systems.","title":"Motivation"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#key-equations","text":"The Lorentz force equation is: \\[ \\vec{F} = q(\\vec{E} + \\vec{v} \\times \\vec{B}) \\] Where: \\( q \\) = charge of the particle \\( \\vec{E} \\) = electric field \\( \\vec{B} \\) = magnetic field \\( \\vec{v} \\) = velocity of the particle","title":"Key Equations"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#simulation-parameters","text":"import numpy as np import matplotlib.pyplot as plt # === Particle and Field Parameters === q = 1.0 # Charge (C) m = 1.0 # Mass (kg) E = np.array([0.0, 0.0, 0.0]) # Electric field (V/m) B = np.array([0.0, 0.0, 1.0]) # Magnetic field (T) # === Initial Conditions === r = np.array([0.0, 0.0, 0.0]) # Position (m) v = np.array([1.0, 0.0, 0.0]) # Velocity (m/s) # === Time Setup === dt = 0.01 # Time step (s) T = 20 # Total time (s) N = int(T / dt) # === Data Storage for Trajectory === trajectory = np.zeros((N, 3)) time = np.linspace(0, T, N) # === Simulation Loop === for i in range(N): # Save current position trajectory[i] = r # Lorentz force: F = q(E + v \u00d7 B) force = q * (E + np.cross(v, B)) # Acceleration a = force / m # Euler integration (can upgrade to Runge-Kutta for higher accuracy) v += a * dt r += v * dt # === Plotting the Trajectory in XY Plane === plt.figure(figsize=(6, 6)) plt.plot(trajectory[:, 0], trajectory[:, 1], label='Trajectory') plt.xlabel('x (m)') plt.ylabel('y (m)') plt.title('Charged Particle in Magnetic Field (Circular Motion)') plt.grid(True) plt.axis('equal') plt.legend() plt.show()","title":"Simulation Parameters"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#observations-and-physical-insight","text":"Circular motion : Occurs when only a magnetic field is present and the initial velocity is perpendicular to the field. Helical motion : Results from a velocity component both parallel and perpendicular to the magnetic field. Drift motion : Emerges when electric and magnetic fields are crossed.","title":"Observations and Physical Insight"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#larmor-radius","text":"\\[ r_L = \\frac{mv_\\perp}{qB} \\]","title":"Larmor Radius:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#cyclotron-frequency","text":"\\[ \\omega_c = \\frac{qB}{m} \\]","title":"Cyclotron Frequency:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#extensions","text":"Add non-uniform magnetic fields. Include relativistic corrections . Simulate plasma behavior with multiple particles.","title":"Extensions"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#conclusion","text":"This simulation gives insight into the fundamental behavior of charged particles under electromagnetic influence. Real-world applications span from fusion reactors to space plasma dynamics and particle beam control in accelerators. import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Parameters q = 1.0 # charge m = 1.0 # mass B = np.array([0, 0, 1.0]) # uniform magnetic field E = np.array([0, 0, 0]) # no electric field v0 = np.array([1.0, 0.0, 1.0]) # velocity with component along B r0 = np.array([0.0, 0.0, 0.0]) dt = 0.01 T = 20 N = int(T / dt) # Arrays r = np.zeros((N, 3)) v = np.zeros((N, 3)) r[0], v[0] = r0, v0 def lorentz_force(v, E, B): return q * (E + np.cross(v, B)) # Integrate using Euler method for i in range(1, N): a = lorentz_force(v[i-1], E, B) / m v[i] = v[i-1] + a * dt r[i] = r[i-1] + v[i] * dt # 3D Plot fig = plt.figure(figsize=(10,6)) ax = fig.add_subplot(111, projection='3d') ax.plot(r[:,0], r[:,1], r[:,2]) ax.set_title('Helical Motion of a Charged Particle') ax.set_xlabel('X') ax.set_ylabel('Y') ax.set_zlabel('Z') plt.show() # Crossed fields: E in x-direction, B in z-direction E = np.array([1.0, 0.0, 0.0]) B = np.array([0.0, 0.0, 1.0]) v0 = np.array([0.0, 1.0, 0.0]) # initial velocity # Reinitialize r = np.zeros((N, 3)) v = np.zeros((N, 3)) r[0], v[0] = r0, v0 for i in range(1, N): a = lorentz_force(v[i-1], E, B) / m v[i] = v[i-1] + a * dt r[i] = r[i-1] + v[i] * dt # 2D Plot of Drift plt.figure(figsize=(8,6)) plt.plot(r[:,0], r[:,1]) plt.title('Drift Motion in Crossed Electric and Magnetic Fields') plt.xlabel('X') plt.ylabel('Y') plt.axis('equal') plt.grid(True) plt.show()","title":"Conclusion"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Circuits \u2014 Problem 1 Equivalent Resistance Using Graph Theory \ud83d\udcd8 Motivation Calculating the equivalent resistance of a circuit is essential in understanding current flow, power distribution, and network behavior. For simple circuits, we can use well-known rules: Series: \\(R_{\\text{eq}} = R_1 + R_2 + \\dots + R_n\\) Parallel: \\(\\displaystyle \\frac{1}{R_{\\text{eq}}} = \\frac{1}{R_1} + \\frac{1}{R_2} + \\dots + \\frac{1}{R_n}\\) However, as circuits grow complex, identifying these combinations becomes harder. Graph Theory Approach Treat each node (junction) as a vertex Treat each resistor as an edge with a weight equal to its resistance Use graph simplification algorithms to reduce the graph This approach allows automatic, programmable simplification of circuits, even with nested and cyclical resistor networks. Mathematical Basis Given a graph \\(G = (V, E)\\) : - \\(V\\) is the set of nodes - \\(E\\) is the set of edges, each with a weight \\(R_i\\) (resistance) We compute equivalent resistance between two nodes \\(a\\) and \\(b\\) using Y-\u0394 transforms , series/parallel reduction , or Kirchhoff's laws formulated in matrix form. We model the circuit as a weighted undirected graph and systematically reduce it using basic rules: \ud83d\udd27 Series Rule If two resistors \\(R_1\\) and \\(R_2\\) connect in series: \\[ R_{\\text{eq}} = R_1 + R_2 \\] \ud83d\udd0c Parallel Rule If they connect in parallel: \\[ \\frac{1}{R_{\\text{eq}}} = \\frac{1}{R_1} + \\frac{1}{R_2} \\Rightarrow R_{\\text{eq}} = \\left( \\frac{1}{R_1} + \\frac{1}{R_2} \\right)^{-1} \\] Full Python Implementation (Graph Reduction) We will build a Python implementation that: Represents circuits as graphs Identifies series and parallel nodes Simplifies the graph until one equivalent resistance remains Full Python Implementation (Graph Reduction) We will build a Python implementation that: Represents circuits as graphs Identifies series and parallel nodes Simplifies the graph until one equivalent resistance remains Full Python Implementation (Graph Reduction) We will build a Python implementation that: Represents circuits as graphs Identifies series and parallel nodes Simplifies the graph until one equivalent resistance remains ```python import networkx as nx import matplotlib.pyplot as plt def combine_parallel(resistances): \"\"\" Combine resistances in parallel using the formula: $$ R_{parallel} = \\frac{1}{\\sum_{i=1}^{n} \\frac{1}{R_i}} $$ \"\"\" inv_sum = sum(1 / r for r in resistances if r > 0) return 1 / inv_sum if inv_sum else float('inf') def simplify_graph(G, source, target): \"\"\" Simplifies the graph by combining parallel and series resistances. Returns the equivalent resistance between source and target . \"\"\" G = G.copy() changed = True while changed: changed = False # Parallel Simplification edges_to_merge = {} for u, v in G.edges(): key = tuple(sorted((u, v))) edges_to_merge.setdefault(key, []).append(G[u][v]['resistance']) for (u, v), res_list in edges_to_merge.items(): if len(res_list) > 1: R_parallel = combine_parallel(res_list) G.remove_edges_from([(u, v)] * G.number_of_edges(u, v)) G.add_edge(u, v, resistance=R_parallel) changed = True # Series Simplification for node in list(G.nodes()): if node in (source, target): continue neighbors = list(G.neighbors(node)) if len(neighbors) == 2: u, v = neighbors if G.degree(node) == 2 and G.has_edge(node, u) and G.has_edge(node, v): r1 = G[node][u]['resistance'] r2 = G[node][v]['resistance'] G.remove_node(node) if G.has_edge(u, v): existing = G[u][v]['resistance'] G[u][v]['resistance'] = combine_parallel([existing, r1 + r2]) else: G.add_edge(u, v, resistance=r1 + r2) changed = True break if G.has_edge(source, target): return G[source][target]['resistance'] else: return float('inf') # No connection found Example test circuit G = nx.Graph() G.add_edge('A', 'B', resistance=4) G.add_edge('B', 'C', resistance=6) G.add_edge('C', 'D', resistance=3) G.add_edge('B', 'D', resistance=2) # Parallel to C-D G.add_edge('D', 'E', resistance=5) Simplify and compute the equivalent resistance Req = simplify_graph(G, 'A', 'E') print(f\"Equivalent resistance between A and E: {Req:.2f} \u03a9\") Visualization def draw_graph(G): pos = nx.spring_layout(G, seed=42) edge_labels = nx.get_edge_attributes(G, 'resistance') nx.draw(G, pos, with_labels=True, node_color='lightblue', node_size=700, font_weight='bold') nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels) plt.title(\"Circuit Graph\") plt.axis('off') plt.tight_layout() plt.show() draw_graph(G)","title":"Circuits \u2014 Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#circuits-problem-1","text":"","title":"Circuits \u2014 Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#equivalent-resistance-using-graph-theory","text":"","title":"Equivalent Resistance Using Graph Theory"},{"location":"1%20Physics/5%20Circuits/Problem_1/#motivation","text":"Calculating the equivalent resistance of a circuit is essential in understanding current flow, power distribution, and network behavior. For simple circuits, we can use well-known rules: Series: \\(R_{\\text{eq}} = R_1 + R_2 + \\dots + R_n\\) Parallel: \\(\\displaystyle \\frac{1}{R_{\\text{eq}}} = \\frac{1}{R_1} + \\frac{1}{R_2} + \\dots + \\frac{1}{R_n}\\) However, as circuits grow complex, identifying these combinations becomes harder.","title":"\ud83d\udcd8 Motivation"},{"location":"1%20Physics/5%20Circuits/Problem_1/#graph-theory-approach","text":"Treat each node (junction) as a vertex Treat each resistor as an edge with a weight equal to its resistance Use graph simplification algorithms to reduce the graph This approach allows automatic, programmable simplification of circuits, even with nested and cyclical resistor networks.","title":"Graph Theory Approach"},{"location":"1%20Physics/5%20Circuits/Problem_1/#mathematical-basis","text":"Given a graph \\(G = (V, E)\\) : - \\(V\\) is the set of nodes - \\(E\\) is the set of edges, each with a weight \\(R_i\\) (resistance) We compute equivalent resistance between two nodes \\(a\\) and \\(b\\) using Y-\u0394 transforms , series/parallel reduction , or Kirchhoff's laws formulated in matrix form. We model the circuit as a weighted undirected graph and systematically reduce it using basic rules:","title":"Mathematical Basis"},{"location":"1%20Physics/5%20Circuits/Problem_1/#series-rule","text":"If two resistors \\(R_1\\) and \\(R_2\\) connect in series: \\[ R_{\\text{eq}} = R_1 + R_2 \\]","title":"\ud83d\udd27 Series Rule"},{"location":"1%20Physics/5%20Circuits/Problem_1/#parallel-rule","text":"If they connect in parallel: \\[ \\frac{1}{R_{\\text{eq}}} = \\frac{1}{R_1} + \\frac{1}{R_2} \\Rightarrow R_{\\text{eq}} = \\left( \\frac{1}{R_1} + \\frac{1}{R_2} \\right)^{-1} \\]","title":"\ud83d\udd0c Parallel Rule"},{"location":"1%20Physics/5%20Circuits/Problem_1/#full-python-implementation-graph-reduction","text":"We will build a Python implementation that: Represents circuits as graphs Identifies series and parallel nodes Simplifies the graph until one equivalent resistance remains","title":"Full Python Implementation (Graph Reduction)"},{"location":"1%20Physics/5%20Circuits/Problem_1/#full-python-implementation-graph-reduction_1","text":"We will build a Python implementation that: Represents circuits as graphs Identifies series and parallel nodes Simplifies the graph until one equivalent resistance remains","title":"Full Python Implementation (Graph Reduction)"},{"location":"1%20Physics/5%20Circuits/Problem_1/#full-python-implementation-graph-reduction_2","text":"We will build a Python implementation that: Represents circuits as graphs Identifies series and parallel nodes Simplifies the graph until one equivalent resistance remains ```python import networkx as nx import matplotlib.pyplot as plt def combine_parallel(resistances): \"\"\" Combine resistances in parallel using the formula: $$ R_{parallel} = \\frac{1}{\\sum_{i=1}^{n} \\frac{1}{R_i}} $$ \"\"\" inv_sum = sum(1 / r for r in resistances if r > 0) return 1 / inv_sum if inv_sum else float('inf') def simplify_graph(G, source, target): \"\"\" Simplifies the graph by combining parallel and series resistances. Returns the equivalent resistance between source and target . \"\"\" G = G.copy() changed = True while changed: changed = False # Parallel Simplification edges_to_merge = {} for u, v in G.edges(): key = tuple(sorted((u, v))) edges_to_merge.setdefault(key, []).append(G[u][v]['resistance']) for (u, v), res_list in edges_to_merge.items(): if len(res_list) > 1: R_parallel = combine_parallel(res_list) G.remove_edges_from([(u, v)] * G.number_of_edges(u, v)) G.add_edge(u, v, resistance=R_parallel) changed = True # Series Simplification for node in list(G.nodes()): if node in (source, target): continue neighbors = list(G.neighbors(node)) if len(neighbors) == 2: u, v = neighbors if G.degree(node) == 2 and G.has_edge(node, u) and G.has_edge(node, v): r1 = G[node][u]['resistance'] r2 = G[node][v]['resistance'] G.remove_node(node) if G.has_edge(u, v): existing = G[u][v]['resistance'] G[u][v]['resistance'] = combine_parallel([existing, r1 + r2]) else: G.add_edge(u, v, resistance=r1 + r2) changed = True break if G.has_edge(source, target): return G[source][target]['resistance'] else: return float('inf') # No connection found","title":"Full Python Implementation (Graph Reduction)"},{"location":"1%20Physics/5%20Circuits/Problem_1/#example-test-circuit","text":"G = nx.Graph() G.add_edge('A', 'B', resistance=4) G.add_edge('B', 'C', resistance=6) G.add_edge('C', 'D', resistance=3) G.add_edge('B', 'D', resistance=2) # Parallel to C-D G.add_edge('D', 'E', resistance=5)","title":"Example test circuit"},{"location":"1%20Physics/5%20Circuits/Problem_1/#simplify-and-compute-the-equivalent-resistance","text":"Req = simplify_graph(G, 'A', 'E') print(f\"Equivalent resistance between A and E: {Req:.2f} \u03a9\")","title":"Simplify and compute the equivalent resistance"},{"location":"1%20Physics/5%20Circuits/Problem_1/#visualization","text":"def draw_graph(G): pos = nx.spring_layout(G, seed=42) edge_labels = nx.get_edge_attributes(G, 'resistance') nx.draw(G, pos, with_labels=True, node_color='lightblue', node_size=700, font_weight='bold') nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels) plt.title(\"Circuit Graph\") plt.axis('off') plt.tight_layout() plt.show() draw_graph(G)","title":"Visualization"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}